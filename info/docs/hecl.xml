<?xml version="1.0" encoding="utf-8"?>

<article xmlns="http://docbook.org/ns/docbook" xmlns:xl="http://www.w3.org/1999/xlink" version="5.0">

<!--
   Copyright 2004-2010 DedaSys LLC.

   Licensed under the Apache License, Version 2.0 (the "License"); you
   may not use this file except in compliance with the License.  You
   may obtain a copy of the License at

   	http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
   implied.  See the License for the specific language governing
   permissions and limitations under the License.
-->

  <info>
    <title>
      <link xl:href="http://www.hecl.org/">
	Hecl - The Mobile Scripting Language
      </link>
    </title>
    <copyright>
      <year>2004</year>
      <year>2005</year>
      <year>2006</year>
      <year>2007</year>
      <year>2008</year>
      <year>2009</year>
      <year>2010</year>
      <holder>
	David N. Welton
      </holder>
    </copyright>
    <author>
      <personname>David N. Welton</personname>
      <affiliation>
	<orgname>hecl.org</orgname>
	<address>
	  <email>hecl@googlegroups.com</email>
	</address>
      </affiliation>
    </author>
  </info>

  <section>
    <title>Introduction</title>

    <para>
      The Hecl Programming Language is a high-level scripting language
      implemented in Java.  It is intended to be small, extensible,
      extremely flexible, and easy to learn and use.
    </para>

    <para>
      Why Hecl?  Hecl is intended as a complement to the Java
      programming language, not a replacement.  It tries to do well
      what Java doesn't, and leaves those tasks to Java for which it
      is best suited, by providing an API that makes it easy to tie
      the two together.  Hecl aims to be a very immediate language -
      you can pick it up and start doing useful things with it quickly
      - even people without formal training.  Hecl is easy to learn.
      Where Java is verbose and rigid, Hecl is forgiving and quick to
      write.  For instance,
      <userinput>System.out.println("Hello World");</userinput>
      vs <userinput>puts "Hello World"</userinput> - 41
      keystrokes (shifted letters count double) versus 22.  Hecl is
      built to <link
      xl:href="http://www.welton.it/articles/scalable_systems.html">"scale
      down"</link> - especially in terms of its users, meaning that
      it is very quick to learn, and can be quickly put to productive
      use even by those who are not programmers by trade.
    </para>

    <para>
      This makes Hecl ideal for large applications written in Java
      that would like to provide a user friendly scripting interface,
      rather than, say, a clunky XML based system.  Examples include:
      scripted web pages, command/control logic in long running
      applications, and, I'm sure, many environments I've never
      considered.  Instead of a simple, static configuration file, you
      can give your users the power to program portions of the system
      to do things that you hadn't thought of when you wrote the
      software originally.
    </para>

    <para>
      Hecl is a small language with a minimal core.  The idea is to
      provide only what's necessary in the language itself, and as
      needed, add in extensions for specific tasks.  Core Hecl is
      small enough to run on my Nokia 3100 cell phone as a J2ME
      application, presenting the interesting possibility of writing
      scripts, or at some point, maybe even scripting entire
      applications, for devices running embedded Java.
    </para>

    <para>
      Contributions in the form of code, ideas, suggestions, or even donations
      are welcome.  Hecl is still growing, so your thoughts are important, and
      you can help shape the language's future.  You can download the latest
      source code via <link xl:href="http://git-scm.com/">git</link> from
      github: <link
      xl:href="http://github.com/davidw/hecl/tree/master">http://github.com/davidw/hecl/tree/master</link>.
    </para>

    <para>
      Hecl is available under the liberal Apache 2.0 open source
      license.  Which says, more or less, that you may use Hecl in
      your own applications, even if they are not open source.  You
      have to give the authors credit, though.  Read the license
      itself to clear up any doubts.  Incidentally, I don't see the
      license as being incompatible with the GPL, so feel free to
      utilize Hecl in your GPL product (I have added a note to this
      effect in the NOTICE file that must accompany products using the
      Hecl code).
    </para>

    <para>
      I owe thanks to a lot of people for Hecl.  First and foremost
      the creator of the Tcl programming language, Dr. John
      Ousterhout.  While I have attempted to improve some things that
      I did not care for in Tcl, it is obvious that the simple,
      extremely flexible command-based approach that Hecl takes is
      derived from Tcl.  I also borrowed some ideas from the (mostly
      defunct) Jacl implementation of Tcl in Java.  Many thanks are
      also due my friend Salvatore Sanfilippo, with whom I have spent
      many hours discussing Hecl, Tcl, and the philosophy of
      programming languages in general.  And of course, I owe a huge
      debt of gratitude to my wife, Ilenia, who puts up with all the
      hours I spend in front of "that damn computer".
    </para>

  </section>

  <section xml:id="installation">
    <title>Installation / Tools &amp; Editors</title>
    <para>
      Hecl is easy to compile and install as a standard J2SE application.

      <note>
	<para>
	  This is only necessary if you'd like to work on Hecl's
	  source code.  If all you want to do is use it, or install it
	  on your mobile phone, these steps aren't necessary - the
	  standard distribution contains everything you need.
	</para>
      </note>
    </para>
    <para>
      <note>
	<para>
	  On Microsoft Windows, you must add your java <filename>bin</filename> directory to the
	  system path, otherwise you will get strange, seemingly unrelated errors!
	</para>
      </note>
    </para>
    <procedure>
      <step>
	<title>Dependencies:</title>

	<para>You will need to install these software packages if you want to rebuild Hecl.</para>

	<simplelist>

	  <member>
	    Obviously, you need a Java SDK - we suggest something recent like 1.5 or 1.6, as that's
	    what most of the Hecl developers have.
	  </member>

	  <member>
	    Depending on what you want to utilize Hecl for, you'll want one or both of the <link xl:href="http://java.sun.com/javame/downloads/index.jsp">Sun Java Wireless Toolkit</link>
	      or <link xl:href="http://code.google.com/android/download.html">Android SDK</link>.
	  </member>

	  <member>
	    Hecl uses the <link xl:href="http://ant.apache.org/">Apache Ant</link> build system, so
	    you need to install that as well to compile Hecl.  If you are on Windows, this may
	    require a bit of extra work.  Here are some <link xl:href="http://blogs.sun.com/rajeshthekkadath/entry/installing_ant_on_windows">instructions
	    for setting up Ant on Windows</link>.
	  </member>
	</simplelist>

      </step>
      <step>
	<para>
	  To compile the standard, J2SE version of Hecl, do this:
	</para>
	<screen>
ant packageCommandline
</screen>
      </step>
      <step>
	<para>
	  You should now have a Hecl.jar file in the
	  <filename>jars/j2se/</filename> directory.  To run it, do
	  this:
	</para>
	<screen>
java -jar jars/j2se/Hecl.jar
hecl> puts "hello world"
hello world
</screen>
      </step>
      <step>
	<para>
	  If you want to check your installation of Hecl, you can run
	  the test suite to make sure everything checks out:
	</para>
	<screen>
java -jar jars/j2se/Hecl.jar tests/suite.hcl
	</screen>
	<para>
	  An (incomplete) performance test is also supplied so that
	  you can compare numbers if you're curious, or want to hack
	  on Hecl to improve its speed:
	</para>
	<screen>
java -jar jars/j2se/Hecl.jar tests/performance.hcl
	</screen>
      </step>

    </procedure>

    <para>
      If you're going to be recompiling (you don't need to recompile if you're only going to be
      writing scripts, though!) Hecl for Java ME, you also need to follow these instructions.
    </para>

    <procedure>
      <step>
	<para>
	  You'll need to download and install Sun's "Java Wireless Toolkit", here: <link xl:href="http://java.sun.com/products/sjwtoolkit/index.jsp" />.
	</para>
      </step>
      <step>
	<para>
	  You also need to make Hecl aware of the WTK.  For instance, in my installation, the
	  <filename>settings.xml</filename> file has the following:
	</para>
	<screen>
&lt;!-- General WTK settings --&gt;
&lt;!-- make it fit for your local installation --&gt;
&lt;property name="my.wtk.home" value="/opt/WTK2.5.2"/&gt;
	</screen>
	<para>You would need to change <filename>/opt/WTK25.2</filename> to wherever the WTK is
	located on your system.</para>
      </step>
    </procedure>

    <para>
      See <xref linkend="j2me"/> for further information on installation and use with J2ME.
    </para>

    <section xml:id="tools_and_editors">
      <title>Tools &amp; Editors</title>
      <para>
	Even if you're not interested in recompiling Hecl to hack on the source code, to write Hecl
	scripts, you need some kind of editor for programming.  Hecl is close enough in syntax to
	the Tcl programming language that editors that support Tcl work well with Hecl.
      </para>

      <itemizedlist>
	<listitem>
	  <para>
	    <emphasis role="strong">Emacs</emphasis>' Tcl mode is easy to use: <userinput>M-x
	    tcl-mode</userinput>, or if you want to associate <filename>.hcl</filename> scripts with
	    tcl-mode, add this to your <filename>.emacs</filename> file:
	  </para>
	  <programlisting>
(setq auto-mode-alist
      (cons '("\\.hcl$" . tcl-mode)
	    auto-mode-alist))
	  </programlisting>
	</listitem>

	<listitem>
	  <para><emphasis role="strong">Eclipse</emphasis> is popular for working on Java projects.
	  It also has a Tcl mode that can be utilized for Hecl scripts like so:
	  </para>
	  <task>
	    <title>Editing Hecl scripts with Eclipse</title>
	    <procedure>
	      <step>
		<para>
		  Install the DLTK from the following URL: <link
		  xl:href="http://download.eclipse.org/technology/dltk/updates"></link>,
		  from within Eclipse.
		</para>
	      </step>

	      <step>
		<para>
		  After downloading you must associate the
		  <filename>*.hcl</filename> files with the Tcl Source Editor.
		</para>

		<para>
		  <menuchoice>
		    <guimenu>Windows</guimenu>
		    <guisubmenu>Preferences</guisubmenu>
		    <guisubmenu>General</guisubmenu>
		    <guisubmenu>Editors</guisubmenu>
		    <guimenuitem>File Associations</guimenuitem>
		  </menuchoice>
		</para>
	      </step>

	      <step>
		<para>
		  Than make a new file type by adding the <filename>*.hcl</filename> file type, and
		  select the Tcl Source Editor.
		</para>
	      </step>

	    </procedure>
	  </task>
	</listitem>

      </itemizedlist>

    </section>

  </section>

  <section xml:id="tutorial">
    <title>Hecl Tutorial</title>
    <note>
      <para>
	This is a general tutorial on the Hecl language - if you're looking for the tutorial about
	Hecl on Java ME, it's here: <link linkend="javame_tutorial">Java ME Tutorial</link>.
      </para>
    </note>
    <para>
      Like many people, I enjoy taking something and experimenting with it before going and reading
      the instructions!  With this in mind, I have written a brief tutorial that you can use to
      start exploring Hecl on your own.
    </para>

    <para>
      To launch the interactive Hecl shell:
    </para>

    <screen>java -jar ./jars/j2se/Hecl.jar</screen>

    <para>This will give you a prompt: <prompt>hecl&gt;</prompt> where you can type in
    commands.</para>

    <para>
      Of course, we would be out of place not to begin with the famous
      "Hello, World".  Behold:
    </para>
    <programlisting>puts "Hello, World"</programlisting>
    <para>
      Hecl is based on the notion of commands, which take any number
      of arguments.  The <command>puts</command> command takes one
      argument, a string, and prints it out.
    </para>
    <para>
      Like all programming languages, Hecl provides variables that may
      be used to store information. Here, we set a variable,
      <varname>rating</varname>, and then print it out in the midst of
      a string.  This is called "interpolation", and is a convenient
      way of creating new strings.
    </para>
	    <programlisting>set rating 10
puts "Hecl, from 1 to 10: $rating"</programlisting>
    <para>
      Something else we notice in the above examples is that we use
      double quotes "" to group a series of things.  In Hecl, commands
      and their arguments are separated by spaces.  Since
      <command>puts</command> only takes one argument, a string, we
      use the quotes to group several words together in order to pass
      them as one string to the command.  Many languages require
      quotes to delineate a string, but in Hecl that is not necessary
      if the string has no spaces in it.  For instance,
      <userinput>puts helloworld</userinput> is legitimate.
    </para>

    <para>
      Something else visible in the above command is that Hecl commands occur one per line, and that
      no line ending is necessary, as in languages like C where lines end in a semicolon.  In Hecl,
      the semicolon is optional, and can be used to put more than one command on a line:
    </para>

    <programlisting>puts "hello" ; puts "world" </programlisting>

    <para>
      Another way of grouping multiple words in Hecl is with braces:
      {}.  Hecl does not automatically perform any substitution on the
      variables or commands grouped within braces, as it does with
      quotes.
    </para>

    <programlisting>puts {The $dollar $signs $are printed	    literally$$ - no substitution}</programlisting>

    <para>
      Aside from the dollar sign, which returns a reference to the
      value of a variable, it is also possible to utilize the results
      of one command as the input of a second command.  For example:
    </para>

    <programlisting>set rating 10
puts "Rating:"
puts [set rating]</programlisting>

    <para>
      In this case, we pass the results of the <command>set</command>
      command to the <command>puts</command> command.  In reality, <userinput>set
	rating</userinput> is just a long way of writing
      <option>$rating</option> but it's a good example.
    </para>

    <para>
      Like everything else in Hecl, we perform math operations as
      commands:
    </para>

    <programlisting>puts "2 + 2 = [+ 2 2]"</programlisting>

    <para>
      In the example, the <command>+</command> takes two arguments,
      adds them together and return the result, which is then printed
      out by the <command>puts </command> command.
    </para>

    <para>
      In order to choose between one or more
    </para>

    <programlisting>set temp 10
if { &lt; $temp 0 } {
    puts "It's freezing"
} else {
    puts "Not freezing"
}</programlisting>

    <para>"while" loop command:</para>

    <programlisting>set i 0
while { &lt; $i 10 } {
    puts "i is now $i"
    incr $i
}
</programlisting>

    <para>Lists:</para>

    <programlisting>set foo [list a b c]
set bar {a b c}
lappend $foo d
lappend $bar d
set foo
# Returns 'a b c d'
set bar
# Returns 'a b c d'
</programlisting>

    <para>Hash tables:</para>

    <programlisting>set foo [hash {a b c d}]
puts [hget $foo a]
# prints 'b'
puts [hget $foo c]
# prints 'd'
hset $foo c 2
puts [hget $foo c]
# prints '2'
puts $foo
# prints 'a b c 2' (although not necessarily in that order)
</programlisting>

    <para>"foreach" loop command:</para>

    <programlisting>set lst {a b c d e f}
foreach {m n} $lst {
    puts  "It is possible to grab two variables at a time: $m $n"
}

foreach {x} $lst {
    puts  "Or one at a time: $x"
}</programlisting>

    <para>
      Create new commands with the "proc" command.  In this example we create a command that prints
      out a numbered list.  In Hecl, commands created within procs normally are only visible within
      that proc, and are cleaned up when the procedure exits.  For exceptions to this rule, see the
      <link linkend="global"><command>global</command></link> and <link
      linkend="upeval"><command>upeval</command></link> commands.
    </para>

    <programlisting>set list {red blue green}
proc printvals {vals} {
    set num 1
    foreach v $vals {
	puts "$num - $v"
	incr $num
    }
}

printvals $list</programlisting>

    <para>
      Hecl is very flexible - in this example, we create a
      "do...while" loop command that works as if it were a native loop
      construct.
    </para>

    <programlisting>proc do {code while condition} {
    upeval $code
    while { upeval $condition } {
	upeval $code
    }
}

set x 100
set foo ""
do {
    append $foo $x
    incr $x
} while { &lt; $x 10 }
set foo
# Returns 100 - because the loop is run once and only once.
</programlisting>

  </section>

  <section xml:id="commands">
    <title>Hecl Commands</title>

    <para>
      These commands are part of the Hecl core and are always present.
    </para>

    <!-- = -->
    <refentry xml:id="equality">
      <refnamediv>
	<refname>= !=</refname> <refpurpose>Integer
	equality</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>=</command>
	  <arg choice="req"><replaceable>num1</replaceable></arg>
	  <arg choice="req"><replaceable>num2</replaceable></arg>
	  <command>!=</command>
	  <arg choice="req"><replaceable>num1</replaceable></arg>
	  <arg choice="req"><replaceable>num2</replaceable></arg>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title> <para>Tests two numbers for
	equality, returning 1 if they are, 0 if they aren't equal.  In
	the case of <command>!=</command>, returns 1 if they are not
	equal, 0 if they are equal.</para>
      </refsect1>
      <refsect1>
	<title>Example</title>
	<programlisting>
puts [= 1 1]
puts [= 0 1]
puts [= 00001 1]
puts [!= 1 1]
	</programlisting>
	<para>Produces:</para>
	<screen>
1
0
1
0
	</screen>
      </refsect1>
    </refentry>


    <!-- + - * / math commands -->
    <refentry xml:id="math">
      <refnamediv>
	<refname>+ - * /</refname>
	<refpurpose>Basic math commands.</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>+</command>
	  <arg choice="req"><replaceable>number</replaceable></arg>
	  <arg choice="opt" rep="repeat"><replaceable>number</replaceable></arg>
	  <command>-</command>
	  <arg choice="req"><replaceable>number</replaceable></arg>
	  <arg choice="req"><replaceable>number</replaceable></arg>
	  <command>*</command>
	  <arg choice="req"><replaceable>number</replaceable></arg>
	  <arg choice="req"><replaceable>number</replaceable></arg>
	  <command>/</command>
	  <arg choice="req"><replaceable>number</replaceable></arg>
	  <arg choice="req"><replaceable>number</replaceable></arg>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>
	<para>
	  The basic math commands take two arguments and carry out a
	  numerical operation on them.  In subtraction, the second
	  argument is taken from the first.  In division, the first
	  argument is divided by the second.
	</para>
      </refsect1>
      <refsect1>
	<title>Example</title>
	  <programlisting>
puts [+ 2 2]
puts [+ 1 2 3]
puts [- 10 1]
puts [* 6 7]
puts [/ 100 5]
	  </programlisting>
	  <para>Produces:</para>
	  <screen>4
6
9
42
20</screen>
      </refsect1>
    </refentry>

    <refentry xml:id="fpmath">
      <refnamediv>
	<refname>abs acos acos asin asin atan atan cbrt ceil cos cosh
cosh exp expm1 floor hypot log log10 log1p pow random round signum sin
sinh sqrt tan tanh tanh</refname>
	<refpurpose>Floating point math commands</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command><replaceable>command</replaceable></command>
	  <arg choice="req"><replaceable>number</replaceable></arg>
	  <arg choice="opt"><replaceable>number</replaceable></arg>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>
	<para>
	  Floating point math commands.  The names are mostly self
	  explanatory, corresponding to the methods found here: <link xl:href="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/Math.html">http://java.sun.com/j2se/1.5.0/docs/api/java/lang/Math.html</link>
	</para>
	<note>
	  <para>
	    Keep in mind that none of these commands are available in
	    the MIDP1.0 version of Hecl, and that the following
	    commands are available only in J2SE versions of Hecl:
	  </para>
	  <para>
	    <command>acos</command> <command>atan</command>
	    <command>ceil</command> <command>round</command>
	    <command>exp</command> <command>floor</command>
	    <command>sin</command> <command>cos</command>
	    <command>sqrt</command> <command>log</command>
	    <command>tan</command> <command>asin</command>
	  </para>
	</note>
	<para>The following are only available in versions of Hecl
	built for Java 1.5 and above.</para>
	<para>
	  <command>cbrt</command> <command>cosh</command>
	  <command>expm1</command> <command>hypot</command>
	  <command>log10</command> <command>log1p</command>
	  <command>signum</command> <command>sinh</command>
	  <command>tanh</command>
	</para>
      </refsect1>
    </refentry>

    <!-- after -->
    <refentry xml:id="after">
      <refnamediv>
	<refname>after</refname>
	<refpurpose>Sleep / delayed script evaluation</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>after</command>

	  <group choice="req">
	    <arg choice="plain">
	      <replaceable>milliseconds</replaceable>
	      <arg><replaceable>script</replaceable></arg>
	    </arg>

	    <arg choice="plain">
	      info
	      <arg choice="opt"><replaceable>event</replaceable></arg>
	    </arg>

	    <arg choice="plain">
	      cancel
	      <arg choice="req"><replaceable>event</replaceable></arg>
	      <arg choice="opt" rep="repeat"><replaceable>event</replaceable></arg>
	    </arg>

	    <arg choice="plain">
	      idle
	      <arg><replaceable>script</replaceable></arg>
	    </arg>

	  </group>

	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>
	<para>
	  The <command>after</command> command is used, in the simple
	  case, to simply halt evaluation of the script for
	  <option><replaceable>milliseconds</replaceable></option>
	  milliseconds, or execute a script after that number of
	  milliseconds.
	</para>
	<para>
	  The after command can also be used to manage timer events in
	  Hecl via the <command>info</command> and
	  <command>cancel</command> subcommands, which, respectively,
	  return information about existing events, and allow the
	  cancellation of events.
	</para>
      </refsect1>
      <refsect1>
	<title>Example</title>
	<para>Pause for 1 second:</para>

	  <programlisting>after 1000</programlisting>

	<para>
	  Run <option><replaceable>script</replaceable></option> after
	  10 seconds, but do not pause execution of the main script:
	</para>

	<programlisting>after 10000 { puts "hello, later world"	}</programlisting>

	<para>Cancel all timers:</para>

	<programlisting>for {set i 1} {&lt; $i 11} {incr $i} {
    puts [after [* 10000 [random]] [list puts "Event number $i"]]
}

after 5000

foreach e [after info] {
    after cancel $e
    puts "Event $e cancelled"
}

twait forever</programlisting>
	<para>Will produce, on average, something like the
	following:</para>
	<screen>timer#1
timer#2
timer#3
timer#4
timer#5
timer#6
timer#7
timer#8
timer#9
timer#10
Event number 9
Event number 4
Event number 10
Event timer#5 cancelled
Event timer#1 cancelled
Event timer#7 cancelled
Event timer#3 cancelled
Event timer#2 cancelled
Event timer#6 cancelled
Event timer#8 cancelled
	</screen>

      </refsect1>
    </refentry>


    <!-- and -->
    <refentry xml:id="and">
      <refnamediv>
	<refname>and</refname>
	<refpurpose>Logical and</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>and</command>
	  <arg choice="req"><replaceable>number</replaceable></arg>
	  <arg choice="opt"><replaceable>number</replaceable></arg>
	  <arg choice="opt"><replaceable>number</replaceable></arg>
	  <arg choice="opt"><replaceable>...</replaceable></arg>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>
	<para>
	  The <command>and</command> command takes one or more
	  arguments, and performs a binary and on them, in sequence.
	</para>
      </refsect1>
      <refsect1>
	<title>Example</title>
	<programlisting>
hecl> and 1 0
0
hecl> and 1 1
1
hecl> and 1
1
hecl> and 2 4
0
hecl> and 5 1
1
hecl> and 5 4
4
hecl> and 1 2 4 8
0
	</programlisting>
      </refsect1>
    </refentry>


    <!-- append -->
    <refentry xml:id="append">
      <refnamediv>
	<refname>append</refname>
	<refpurpose>Append text to a variable.</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>append</command>
	  <arg choice="req"><replaceable>varreference</replaceable></arg>
	  <arg choice="req"><replaceable>string</replaceable></arg>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>
	<para>
	  The append command takes two arguments, a variable reference, and a string to append to the variable.
	</para>
      </refsect1>
      <refsect1>
	<title>Example</title>
	  <programlisting>
set foo "bar"
append $foo "beebop"
# The foo variable now contains the string barbeebop
	  </programlisting>
	  <para>Produces:</para>
	  <screen>barbeebop</screen>
      </refsect1>
    </refentry>

    <!-- break -->
    <refentry xml:id="break">
      <refnamediv>
	<refname>break</refname>
	<refpurpose>Break out of a loop.</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>break</command>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>
	<para>
	  The break command breaks out of a loop.  If this command is
	  not run from within a loop - the <command>while</command> or
	  <command>foreach</command> commands for instance, it
	  generates an error.
	</para>
      </refsect1>
      <refsect1>
	<title>Example</title>
	  <programlisting>
set i 0
while { true } {
    if { > $i 100 } {
        break
    }
    incr $i
}
	  </programlisting>
	<para>
	  In what would otherwise be an endless loop, the break
	  command is used to exit.
	</para>
      </refsect1>
    </refentry>

    <refentry xml:id="bgerror">
      <refnamediv>
       <refname>bgerror</refname>
       <refpurpose>Called for background task errors.</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
       <cmdsynopsis>
         <command>append</command>
         <arg choice="req"><replaceable>message</replaceable></arg>
       </cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
       <title>Description</title>
       <para>
         Hecl calls <command>bgerror</command> when there is a
         problem in a background task (created with the
         <command>after</command> command, for instance).
       </para>
      </refsect1>
      <refsect1>
       <title>Example</title>
         <programlisting>
hecl> proc bgerror {msg} { puts "Houston, we have a problem: $msg" }
hecl> after 1 { beebop }
timer#7
         </programlisting>
         <para>Produces:</para>
         <screen>Houston, we have a problem: Command beebop does not exist</screen>
      </refsect1>
    </refentry>


    <!-- catch -->
    <refentry xml:id="catch">
      <refnamediv>
	<refname>catch</refname>
	<refpurpose>
	  Evaluates a script, catching any errors.
	</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>catch</command>
	  <arg choice="req"><replaceable>script</replaceable></arg>
	  <arg choice="opt"><replaceable>varname</replaceable></arg>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>
	<para>
	  The catch command evaluates a script, and returns 0 if the
	  script evaluated successfully.  If there were errors, catch
	  returns 1.  Optionally, a variable name may be passed to the
	  command, where the results of the script evaluation will be
	  placed.  In the case of errors, the stack trace will be
	  placed in the variable argument.  If the script executes
	  without problems, the variable will contain the result of
	  the script execution.
	</para>
      </refsect1>
      <refsect1>
	<title>Example</title>
	  <programlisting>
catch nosuchcommand foo
set foo
	  </programlisting>
	  <para>Produces:</para>
	<screen>
	  {ERROR {Command nosuchcommand does not exist}}
	</screen>
      </refsect1>
    </refentry>

    <!-- classof -->
    <refentry xml:id="classof">
      <refnamediv>
	<refname>classof</refname>
	<refpurpose>
	  Returns the name of the internal class of a Hecl Thing.
	</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>classof</command>
	  <arg choice="req"><replaceable>variable</replaceable></arg>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>
	<para>
	  The classof command returns a string containing the Java
	  name of the class that the Hecl variable contains
	  internally.
	</para>
      </refsect1>
      <refsect1>
	<title>Example</title>
	  <programlisting>
classof [+ 1 2]

classof "foo"
	  </programlisting>
	  <para>Produces:</para>
	<screen>
org.hecl.IntThing

org.hecl.StringThing
	</screen>
      </refsect1>
    </refentry>

    <refentry xml:id="clock">
      <refnamediv>
	<refname>clock</refname>
	<refpurpose>Provides time utilities</refpurpose>
      </refnamediv>

      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>clock</command>
	  <group>
	    <arg choice="req">seconds</arg>
	    <arg choice="req">time</arg>
	    <arg choice="req">format <replaceable>format</replaceable></arg>
	  </group>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>
	<para>The <command>clock</command> command is used to return
	  information on the current time.  With the
	<option>seconds</option> option, the number of seconds since
	  January 1st, 1970 are returned.  With the
	<option>time</option> option, milliseconds since that date are
	returned.
	</para>
	<para>With the <option>format</option> option, the
	<command>clock</command> command takes a millisecond value and
	returns a formatted date and time.  For example:
	</para>
      </refsect1>
      <refsect1>
	<title>Example</title>
	<screen>
hecl&gt; clock format [clock time]
Fri Jun 15 13:22:20 CEST 2007
	</screen>
      </refsect1>

    </refentry>

    <!-- continue -->
    <refentry xml:id="continue">
      <refnamediv>
	<refname>continue</refname>
	<refpurpose>Skip to next cycle of a loop</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>continue</command>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>
	<para>
	  The continue command is used within the bodies of looping
	  commands such as <command>if</command> and
	  <command>while</command>.  When <command>continue</command>
	  is called, execution of the loop body stops and and
	  execution moves on to the next iteration of the loop.
	</para>
      </refsect1>
      <refsect1>
	<title>Example</title>
	<programlisting>
set i 0
set res {}
foreach x {a b c d e} {
    incr $i
    continue
    append $res $x
}
puts $i
puts $res
	</programlisting>
	<para>Produces:</para>
	<screen>5</screen>
	<para>
	  The res variable is never appended to, so printing it out
	  produces an empty string.
	</para>
      </refsect1>
    </refentry>

    <!-- copy -->
    <refentry xml:id="copy">
      <refnamediv>
	<refname>copy</refname>
	<refpurpose>Copy a Hecl value.</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>cd</command>
	  <arg choice="req"><replaceable>value</replaceable></arg>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>
	<para>
	  The <command>copy</command> command makes a deep copy of a
	  Hecl value, whereas normally, Hecl variables contain
	  references.
	</para>
      </refsect1>
      <refsect1>
	<title>Example</title>
	<programlisting>hecl&gt; set foo 1
set bee $foo
set bop [copy $foo]
incr $foo
puts "foo is $foo"
puts "bee is $bee"
puts "bop is $bop"
	</programlisting>
	<para>Produces:</para>
	<screen>foo is 2
bee is 2
bop is 1
</screen>
      </refsect1>
    </refentry>

    <refentry xml:id="double">
      <refnamediv>
	<refname>double</refname>
	<refpurpose>Cast as a double</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>double</command>
	  <arg choice="req"><replaceable>number</replaceable></arg>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>
	<para>When given a number
	  <option><replaceable>number</replaceable></option>, return
	its value cast as a double.
	</para>
	<important>
	  <para>
	    This command does not appear in the MIDP1.0 version of
	    Hecl, because it doesn't deal with floating point.
	  </para>
	</important>
      </refsect1>
    </refentry>

    <!-- eq -->
    <refentry xml:id="eq">
      <refnamediv>
	<refname>eq</refname>
	<refpurpose>Tests string equivalence.</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>eq</command>
	  <arg choice="req"><replaceable>string1</replaceable></arg>
	  <arg choice="req"><replaceable>string2</replaceable></arg>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>
	<para>
	  The <command>eq</command> commands compares two strings,
	  returning 1 if they are equal, 0 if they are not.
	</para>
      </refsect1>
      <refsect1>
	<title>Example</title>
	  <programlisting>
if {eq 1 1.0} {
    puts "True"
} else {
    puts "False"
}
	  </programlisting>
	  <para>Produces:</para>
	  <screen>False</screen>

	<para>
	  Despite being numerically equivalent, the strings "1" and
	  "1.0" are different.
	</para>
      </refsect1>
    </refentry>

    <refentry xml:id="eval">
      <refnamediv>
	<refname>eval</refname>
	<refpurpose>Evaluate Hecl code.</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>eval</command>
	  <arg choice="req"><replaceable>code</replaceable></arg>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>
	<para>
	  The <command>eval</command> command takes a string
	  containing Hecl commands, evaluates them, and returns the
	  result.
	</para>
      </refsect1>
      <refsect1>
	<title>Example</title>
	  <programlisting>
set i 0
set str {incr}
lappend $str "i"
eval $str
puts $i
	  </programlisting>
	  <para>Produces:</para>
	  <screen>1</screen>
      </refsect1>
    </refentry>

    <refentry xml:id="exit">
      <refnamediv>
	<refname>exit</refname>
	<refpurpose>Exit the current process</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>exit</command>
	  <arg choice="opt"><replaceable>exitcode</replaceable></arg>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>
	<para>
	  The <command>exit</command> command stops the execution of
	  the current process.  It causes the
	  <option><replaceable>exitcode</replaceable></option> (an
	  integer) to be returned by the process.
	</para>
      </refsect1>
    </refentry>

    <refentry xml:id="false">
      <refnamediv>
	<refname>false</refname>
	<refpurpose>Return false</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>false</command>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>
	<para>
	  The <command>false</command> command is the opposite of
	  <command>true</command>, and always returns a false value.
	</para>
      </refsect1>
    </refentry>

    <refentry xml:id="filter">
      <refnamediv>
	<refname>filter</refname>
	<refpurpose>Filter a list.</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>filter</command>
	  <arg choice="req"><replaceable>list</replaceable></arg>
	  <arg choice="req"><replaceable>varname</replaceable></arg>
	  <arg choice="req"><replaceable>script</replaceable></arg>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>
	<para>
	  The <command>filter</command> command takes a list and
	  filters it according to the code provided in
	  <option><replaceable>code</replaceable></option>.  The
	  current element of the list being considered is stored in
	  the <option><replaceable>varname</replaceable></option>
	  provided.  A list of 'matches' is returned.
	</para>
      </refsect1>
      <refsect1>
	<title>Example</title>
	  <programlisting>
set lst {1 2 3 4 5 4 3 2 1}
puts [filter $lst x {= $x 4}]
	  </programlisting>
	  <para>Produces:</para>
	  <screen>4 4</screen>
      </refsect1>
    </refentry>

    <refentry xml:id="float">
      <refnamediv>
	<refname>float</refname>
	<refpurpose>Cast as a float</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>float</command>
	  <arg choice="req"><replaceable>number</replaceable></arg>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>
	<para>When given a number
	  <option><replaceable>number</replaceable></option>, return
	its value cast as a float.
	</para>
	<important>
	  <para>
	    This command does not appear in the MIDP1.0 version of
	    Hecl, because it doesn't deal with floating point.
	  </para>
	</important>
      </refsect1>
    </refentry>

    <refentry xml:id="for">
      <refnamediv>
	<refname>for</refname>
	<refpurpose>For loop.</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>for</command>
	  <arg choice="req"><replaceable>initialization</replaceable></arg>
	  <arg choice="req"><replaceable>test</replaceable></arg>
	  <arg choice="req"><replaceable>step</replaceable></arg>
	  <arg choice="req"><replaceable>body</replaceable></arg>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>
	<para>
	  The <command>for</command> command is like in many other
	  languages like C and Java.  As arguments, it takes an
	  <option><replaceable>initialization</replaceable></option>
	  option, which is often used to set a variable to some
	  initial value, a
	  <option><replaceable>test</replaceable></option> to
	  determine whether to continue running, a
	  <option><replaceable>step</replaceable></option> script
	  option which is run at each iteration of the body (to
	  increment a variable, for example), and the body itself.
	</para>
      </refsect1>
      <refsect1>
	<title>Example</title>
	  <programlisting>
set out {}
for {set i 0} {&lt; $i 10} {incr $i} {
    append $out $i
}
puts $out
	  </programlisting>
	  <para>Produces:</para>
	  <screen>0123456789</screen>
      </refsect1>
    </refentry>

    <refentry xml:id="foreach">
      <refnamediv>
	<refname>foreach</refname>
	<refpurpose>Iterate over elements in a list.</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>foreach</command>
	  <arg choice="req"><replaceable>varname</replaceable></arg>
	  <arg choice="req"><replaceable>list</replaceable></arg>
	  <arg choice="req"><replaceable>body</replaceable></arg>
	  <command>foreach</command>
	  <arg choice="req"><replaceable>varlist</replaceable></arg>
	  <arg choice="req"><replaceable>list</replaceable></arg>
	  <arg choice="req"><replaceable>body</replaceable></arg>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>
	<para>
	  The foreach command iterates over a list.  For each element
	  of the list,
	  <option><replaceable>varname</replaceable></option> is set
	  to a new element of the list, and then
	  <option><replaceable>body</replaceable></option> is run.
	</para>
      </refsect1>
      <refsect1>
	<title>Example</title>
	  <programlisting>
set lst {a b c d e}
set res {}
foreach el $lst {
    append $res $el
}
puts $res
	  </programlisting>
	  <para>Produces:</para>
	  <screen>abcde</screen>
      </refsect1>
    </refentry>

    <!-- global -->
    <refentry xml:id="global">
      <refnamediv>
	<refname>global</refname>
	<refpurpose>Use global variable from within a proc.</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>global</command>
	  <arg choice="req"><replaceable>varname</replaceable></arg>
	  <arg choice="opt" rep="repeat"><replaceable>varname</replaceable></arg>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>
	<para>
	  By default, Hecl variables are always local.  Global
	  variables are not visible from within procedures.  The
	  <command>global</command> command makes global variable
	  <option><replaceable>varname</replaceable></option> visible
	  within a procedure.
	</para>
      </refsect1>
      <refsect1>
	<title>Example</title>
	  <programlisting>
set foo 1
proc incfoo {} {
    global foo
    incr $foo
}
incfoo
puts $foo
	  </programlisting>
	  <para>Produces:</para>
	  <screen>2</screen>
      </refsect1>
    </refentry>

    <refentry xml:id="hasclass">
      <refnamediv>
	<refname>hasclass</refname>
	<refpurpose>An interface to <methodname>Class.forName</methodname></refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>hasclass</command>
	  <arg choice="req"><replaceable>classname</replaceable></arg>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>
	<para>
	  Reports whether a given class is present or not.
	</para>
	<important>
	  <para>
	    Keep in mind that in J2ME, using an obfuscator, class
	    names may not be what you think they are!  Only use this
	    for system-defined classes.
	  </para>
	</important>
      </refsect1>
      <refsect1>
	<title>Example</title>
	<screen>
hecl> hasclass org.hecl.net.HttpCmd
1
hecl> hasclass oogyboogy
0
	</screen>
      </refsect1>
    </refentry>

    <!-- hash, hget, hset -->
    <refentry xml:id="hash">
      <refnamediv>
	<refname>hash</refname>
	<refpurpose>Create and manipulate hash tables.</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>hash</command>
	  <arg choice="req"><replaceable>list</replaceable></arg>
	  <command>hget</command>
	  <arg choice="req"><replaceable>hash</replaceable></arg>
	  <arg choice="req"><replaceable>key</replaceable></arg>
	  <command>hset</command>
	  <arg choice="req"><replaceable>hash</replaceable></arg>
	  <arg choice="req"><replaceable>key</replaceable></arg>
	  <arg choice="req"><replaceable>value</replaceable></arg>
	  <command>hcontains</command>
	  <arg choice="req"><replaceable>hash</replaceable></arg>
	  <arg choice="req"><replaceable>key</replaceable></arg>
	  <command>hclear</command>
	  <arg choice="req"><replaceable>hash</replaceable></arg>
	  <command>hkeys</command>
	  <arg choice="req"><replaceable>hash</replaceable></arg>
	  <command>hremove</command>
	  <arg choice="req"><replaceable>hash</replaceable></arg>
	  <arg choice="req"><replaceable>key</replaceable></arg>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>
	<para>
	  The <command>hash</command> command takes an even-numbered
	  list and creates a hash table from it, using the even
	  elements as keys, and odd elements as values.  A new hash
	  table is returned.  The <command>hget</command> and
	  <command>hset</command> commands operate on hash tables.
	  Both take a hash table as their first argument.
	  <command>hget</command> also takes a key, and returns the
	  corresponding value, or an error if no key by that name
	  exists.  To determine whether a given key exists, use the
	  <command>hcontains</command> command, which returns true or
	  false depending on whether the key exists in the hash table.
	</para>
	<para>
	  The
	  <command>hkeys</command> command returns the keys of the
	  hash table, as a list.
	</para>
	<para>
	  The <command>hclear</command> command clears an entire hash
	  table, whereas <command>hremove</command> removes the value
	  associated with a given key.
	</para>
      </refsect1>
      <refsect1>
	<title>Example</title>
	  <programlisting>
set foo [hash {a b c d}]
hset $foo a 42
puts [hget $foo a]
	  </programlisting>
	  <para>Produces:</para>
	  <screen>42</screen>
      </refsect1>
    </refentry>

    <!-- if -->
    <refentry xml:id="if">
      <refnamediv>
	<refname>if</refname>
	<refpurpose>Conditionally execute code.</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>if</command>
	  <arg choice="req"><replaceable>test</replaceable></arg>
	  <arg choice="req"><replaceable>code</replaceable></arg>
	  <group choice="opt" rep="repeat">
	    <arg choice="req"><option>elseif</option></arg>
	    <arg choice="req"><replaceable>test</replaceable></arg>
	    <arg choice="req"><replaceable>code</replaceable></arg>
	  </group>
	  <group choice="opt">
	    <arg choice="req"><option>else</option></arg>
	    <arg choice="req"><replaceable>code</replaceable></arg>
	  </group>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>
	<para>
	  The if command executes Hecl code conditionally.  In its
	  most basic form, it executes a
	  <option><replaceable>test</replaceable></option>.  If the
	  results are not 0, then it executes
	  <option><replaceable>code</replaceable></option>.  If not,
	  no further actions take place.  <command>if</command> may
	  take any number of <option>elseif</option> clauses, which
	  have their own
	  <option><replaceable>test</replaceable></option> and
	  <option><replaceable>code</replaceable></option>.  Finally,
	  if none of the conditions has matched, it is also possible
	  to supply an <option>else</option> clause that will be
	  executed if the results of the if and elseif tests were all
	  false.
	</para>
      </refsect1>
      <refsect1>
	<title>Example</title>
	  <programlisting>
if { true } {
    puts "true"
} else {
    puts "false"
}
	  </programlisting>
	  <para>Produces:</para>
	  <screen>true</screen>
	  <programlisting>
if { > 0 1 } {
    puts "true"
} else {
    puts "false"
}
	  </programlisting>
	  <para>Produces:</para>
	  <screen>false</screen>
      </refsect1>
    </refentry>

    <!-- incr -->
    <refentry xml:id="incr">
      <refnamediv>
	<refname>incr</refname>
	<refpurpose>Increment a variable.</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>incr</command>
	  <arg choice="req"><replaceable>varreference</replaceable></arg>
	  <arg choice="req"><replaceable>integer</replaceable></arg>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>
	<para>
	  The <command>incr</command> command takes a variable
	  reference, and adds <option><replaceable>integer to
	  it</replaceable></option>.
	</para>
      </refsect1>
      <refsect1>
	<title>Example</title>
	  <programlisting>
set foo 1
incr $foo
puts "foo is $foo"
incr $foo 10
puts "foo is now $foo"
	  </programlisting>
	  <para>Produces:</para>
	  <screen>2
12</screen>
      </refsect1>
    </refentry>

    <!-- intro -->
     <refentry xml:id="intro">
      <refnamediv>
	<refname>intro</refname>
	<refpurpose>Introspection command.</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>intro</command>
	  <group>
	    <arg choice="req">commands</arg>
	  </group>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>
	<para>
	  The <command>intro</command> command is used for Hecl
	  introspection.  It takes a subcommand which causes it to
	  perform the desired function.
	</para>
      </refsect1>
      <refsect1>
	<title>Example</title>
	  <programlisting>
 puts [sort [intro commands]]
	  </programlisting>
	  <para>Produces: (depending on the available commands)</para>
	  <screen>* + - / &lt; = &gt; append break catch continue copy eq eval filter for
foreach global hash hget hset if incr intro join lappend lindex
list llen lset proc puts ref return search set strindex strlen sort
source split time true upeval while</screen>
      </refsect1>
    </refentry>

    <!-- join -->
     <refentry xml:id="join">
      <refnamediv>
	<refname>join</refname>
	<refpurpose>Join elements of a list to create a string.</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>join</command>
	  <arg choice="req"><replaceable>list</replaceable></arg>
	  <arg choice="opt"><replaceable>string</replaceable></arg>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>
	<para>
	  The <command>join</command> command takes a
	  <option><replaceable>list</replaceable></option> argument,
	  and optionally, a
	  <option><replaceable>string</replaceable></option>
	  argument.  It joins all elements of the list together with
	  the string, or, if a string is not provided, with a space.
	</para>
      </refsect1>
      <refsect1>
	<title>Example</title>
	  <programlisting>
puts [join {a b c} "|"]
	  </programlisting>
	  <para>Produces:</para>
	  <screen>a|b|c</screen>
      </refsect1>
    </refentry>

    <!-- lappend -->
     <refentry xml:id="lappend">
      <refnamediv>
	<refname>lappend</refname>
	<refpurpose>Append an element to a list.</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>lappend</command>
	  <arg choice="req"><replaceable>listreference</replaceable></arg>
	  <arg choice="req"><replaceable>element</replaceable></arg>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>
	<para>
	  The <command>lappend</command> takes a reference to a list,
	  and an element to add to that list.
	</para>
      </refsect1>
      <refsect1>
	<title>Example</title>
	  <programlisting>
set foo a
lappend $foo "b"
puts $foo
lappend $foo "c d"
puts $foo
	  </programlisting>
	  <para>Produces:</para>
	  <screen>a b
a b {c d}</screen>
      </refsect1>
    </refentry>

    <!-- lindex -->
    <refentry xml:id="lindex">
      <refnamediv>
	<refname>lindex</refname>
	<refpurpose>Return the Nth element of a list</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>lindex</command>
	  <arg choice="req"><replaceable>list</replaceable></arg>
	  <arg choice="req"><replaceable>index</replaceable></arg>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>
	<para>
	  The <command>lindex</command> command takes a list and an
	  index number as arguments, and return's the index'th element
	  of the list.
	</para>
      </refsect1>
      <refsect1>
	<title>Example</title>
	<programlisting>
puts [lindex {a b c} 2]
	</programlisting>
	<para>Produces:</para>
	<screen>c</screen>
      </refsect1>
    </refentry>


    <!-- list -->
     <refentry xml:id="list">
      <refnamediv>
	<refname>list</refname>
	<refpurpose>Create a list</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>list</command>
	  <arg choice="req"><replaceable>element</replaceable></arg>
	  <group choice="opt" rep="repeat">
	    <arg choice="req"><replaceable>element</replaceable></arg>
	  </group>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>
	<para>
	  The <command>list</command> command takes any number of
	  arguments and returns a list.
	</para>
      </refsect1>
      <refsect1>
	<title>Example</title>
	<programlisting>
puts [list a b c [list 1 2 3]]
	</programlisting>
	<para>Produces:</para>
	<screen>a b c {1 2 3}</screen>
      </refsect1>
    </refentry>

    <!-- llen -->
     <refentry xml:id="llen">
      <refnamediv>
	<refname>llen</refname>
	<refpurpose>List length.</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>llen</command>
	  <arg choice="req"><replaceable>list</replaceable></arg>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>
	<para>
	  The <command>llen</command> returns the length of its list
	  argument.
	</para>
      </refsect1>
      <refsect1>
	<title>Example</title>
	  <programlisting>
puts [llen {1 2 3 {a b c}}]
	  </programlisting>
	  <para>Produces:</para>
	  <screen>4</screen>
      </refsect1>
    </refentry>

    <!-- lrange -->
    <refentry xml:id="lrange">
      <refnamediv>
	<refname>lrange</refname>
	<refpurpose>Get range of elements from a list.</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>lrange</command>
	  <arg choice="req"><replaceable>list</replaceable></arg>
	  <arg choice="req"><replaceable>first</replaceable></arg>
	  <arg choice="req"><replaceable>last</replaceable></arg>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>
	<para>
	  The <command>lrange</command> command fetches a range of
	  elements from
	  <option><replaceable>list</replaceable></option>, starting
	  at element <option><replaceable>first</replaceable></option>
	  and ending at <option><replaceable>last</replaceable></option>.
	</para>
      </refsect1>
      <refsect1>
	<title>Example</title>
	  <programlisting>
lrange {a b c d e f g} 0 2
	  </programlisting>
	  <para>Produces:</para>
	  <screen>a b c</screen>
      </refsect1>
    </refentry>

    <!-- lset -->
    <refentry xml:id="lset">
      <refnamediv>
	<refname>lset</refname>
	<refpurpose>Set list elements.</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>lset</command>
	  <arg choice="req"><replaceable>listref</replaceable></arg>
	  <arg choice="req"><replaceable>index</replaceable></arg>
	  <arg choice="opt"><replaceable>replacement</replaceable></arg>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>
	<para>
	  The <command>lset</command> command sets the
	  <option><replaceable>index</replaceable></option>'th element
	  of the list to
	  <option><replaceable>replacement</replaceable></option>.  If
	  <option><replaceable>replacement</replaceable></option> is
	  not present, then the element is deleted.
	</para>
      </refsect1>
      <refsect1>
	<title>Example</title>
	  <programlisting>
    set lst {a b c}
    lset $lst 1 x
    puts $lst

    lset $lst 1
    puts $lst
	  </programlisting>
	  <para>Produces:</para>
	  <screen>a x c
a c</screen>
      </refsect1>
    </refentry>

    <refentry xml:id="max">
      <refnamediv>
	<refname>max</refname>
	<refpurpose>Returns the greater of two numbers</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>max</command>
	  <arg choice="req"><replaceable>numbera</replaceable></arg>
	  <arg choice="req"><replaceable>numberb</replaceable></arg>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>
	<para>
	  The <command>max</command> command returns the greater of two numbers.
	</para>
      </refsect1>
    </refentry>


    <refentry xml:id="min">
      <refnamediv>
	<refname>min</refname>
	<refpurpose>Returns the smaller of two numbers</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>min</command>
	  <arg choice="req"><replaceable>numbera</replaceable></arg>
	  <arg choice="req"><replaceable>numberb</replaceable></arg>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>
	<para>
	  The <command>min</command> command returns the lesser of two numbers.
	</para>
      </refsect1>
    </refentry>

    <!-- ne -->
    <refentry xml:id="ne">
      <refnamediv>
	<refname>ne</refname>
	<refpurpose>String "not equal".</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>ne</command>
	  <arg choice="req"><replaceable>string1</replaceable></arg>
	  <arg choice="req"><replaceable>string2</replaceable></arg>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>
	<para>
	  The <command>ne</command> commands compares two strings,
	  returning 0 if they are equal, 1 if they are not.
	</para>
      </refsect1>
      <refsect1>
	<title>Example</title>
	  <programlisting>
if {ne 1 00001} {
    puts "True"
} else {
    puts "False"
}
	  </programlisting>
	  <para>Produces:</para>
	  <screen>True</screen>
      </refsect1>
    </refentry>

    <!-- not -->
    <refentry xml:id="not">
      <refnamediv>
	<refname>not</refname>
	<refpurpose>Logical not</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>not</command>
	  <arg choice="req"><replaceable>number</replaceable></arg>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>
	<para>
	  The <command>not</command> command performs a logical not on
	  the argument given to it.
	</para>
      </refsect1>
      <refsect1>
	<title>Example</title>
	<programlisting>
hecl> not 0
1
hecl> not 1
0
hecl> not 4
0
	</programlisting>
      </refsect1>
    </refentry>

    <!-- or -->
    <refentry xml:id="or">
      <refnamediv>
	<refname>or</refname>
	<refpurpose>Logical or</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>or</command>
	  <arg choice="req"><replaceable>number</replaceable></arg>
	  <arg choice="opt"><replaceable>number</replaceable></arg>
	  <arg choice="opt"><replaceable>number</replaceable></arg>
	  <arg choice="opt"><replaceable>...</replaceable></arg>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>
	<para>
	  The <command>or</command> command does a binary or of the
	  numbers passed to it, so it can also be used as a logical
	  or.
	</para>
      </refsect1>
      <refsect1>
	<title>Example</title>
	<programlisting>
hecl> or 1
1
hecl> or 0
0
hecl> or 1 0
1
hecl> or 2 4
6
hecl> or 1 2 4
7
	</programlisting>
      </refsect1>
    </refentry>


    <!-- proc -->
    <refentry xml:id="proc">
      <refnamediv>
	<refname>proc</refname>
	<refpurpose>Create a new procedure.</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>proc</command>
	  <arg choice="opt"><replaceable>name</replaceable></arg>
	  <arg choice="req"><replaceable>arglist</replaceable></arg>
	  <arg choice="req"><replaceable>body</replaceable></arg>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>
	<para>
	  The <command>proc</command> command creates new procedures, which are virtually
	  indistinguishable from built-in Hecl
	  commands.  <option><replaceable>name</replaceable></option> is the name of the new
	  command, or, if it is absent, an anonymous procedure is created (and should be stored in a
	  variable).
	  <option><replaceable>arglist</replaceable></option> is a
	  list of arguments that the new command will take and make
	  available as local variables within the
	  <option><replaceable>body</replaceable></option>, which is
	  the code executed every time the command is called.  If the
	  last element of the argument list is <option>args</option>,
	  the variable <varname>args</varname> is a list that is
	  filled with any arguments (including 0) above and beyond the
	  number of arguments specified for the proc.
	</para>
      </refsect1>
      <refsect1>
	<title>Example</title>
	  <programlisting>
proc addlist {lst} {
    set res 0
    foreach e $lst {
	incr $res $e
    }
    return $res
}

puts [addlist {1 2 3 4 5}]
	  </programlisting>
	  <para>Produces:</para>
	  <screen>15</screen>
      </refsect1>
      <refsect1>
	<title>args Example</title>
	  <programlisting>
proc showargs {args} {
    puts "Args: $args"
}
showargs
showargs x y z
	</programlisting>
	<para>Produces:</para>
	<screen>Args: 
Args: x y z</screen>
      </refsect1>

      <refsect1>
	<title>Anonymous proc Example</title>
	  <programlisting>
set foo [proc {x} { puts $x }]
$foo beebop
	</programlisting>
	<para>Produces:</para>
	<screen>beebop</screen>
      </refsect1>


    </refentry>

     <!-- puts -->
     <refentry xml:id="puts">
      <refnamediv>
	<refname>puts</refname>
	<refpurpose>Print text.</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>puts</command>
	  <arg choice="req"><replaceable>text</replaceable></arg>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>
	<para>
	  The <command>puts</command> command prints
	  <option><replaceable>text</replaceable></option> to stdout.
	</para>
      </refsect1>
      <refsect1>
	<title>Example</title>
	  <programlisting>
puts "Hello, world"
	  </programlisting>
	  <para>Produces:</para>
	  <screen>Hello, world</screen>
      </refsect1>
    </refentry>

    <refentry xml:id="rename">
      <refnamediv>
	<refname>rename</refname>
	<refpurpose>Rename a command</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>rename</command>
	  <arg choice="req"><replaceable>cmdname</replaceable></arg>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>
	<para>Renames a Hecl command.</para>
      </refsect1>
      <refsect1>
	<title>Example</title>
	<screen>
hecl> rename puts send_it_to_the_screen
hecl> send_it_to_the_screen "hello world"
hello world
	</screen>
      </refsect1>
    </refentry>

    <!-- return -->
    <refentry xml:id="return">
      <refnamediv>
	<refname>return</refname>
	<refpurpose>Returns a value from a procedure.</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>return</command>
	  <arg choice="req"><replaceable>value</replaceable></arg>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>
	<para>
	  The <command>return</command> command returns a value from a
	  <command>proc</command> command.
	</para>
      </refsect1>
      <refsect1>
	<title>Example</title>
	  <programlisting>
proc someproc {} {
    set res 1
    return $res
    set res 2
    return $res
}
puts [someproc]
	  </programlisting>
	  <para>Produces:</para>
	  <screen>1</screen>
      </refsect1>
    </refentry>

    <!-- search -->
    <refentry xml:id="search">
      <refnamediv>
	<refname>search</refname>
	<refpurpose>Find the first instance of something in a list.</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>search</command>
	  <arg choice="req"><replaceable>list</replaceable></arg>
	  <arg choice="req"><replaceable>varname</replaceable></arg>
	  <arg choice="req"><replaceable>script</replaceable></arg>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>
	<para>
	  The <command>search</command> command is similar to
	  <command>filter</command> in functionality, except that it
	  stops searching on the first match.
	</para>
      </refsect1>
      <refsect1>
	<title>Example</title>
	  <programlisting>
set lst {1 2 3 4 5 4 3 2 1}
puts [search $lst x {= $x 4}]
	  </programlisting>
	  <para>Produces:</para>
	  <screen>4</screen>
      </refsect1>
    </refentry>

    <!-- set -->
    <refentry xml:id="set">
      <refnamediv>
	<refname>set</refname>
	<refpurpose>Set a variable.</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>set</command>
	  <arg choice="req"><replaceable>varname</replaceable></arg>
	  <arg choice="opt"><replaceable>value</replaceable></arg>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>
	<para>
	  The <command>set</command> sets the value of a variable
	  <option><replaceable>varname</replaceable></option> to value
	  <option><replaceable>value</replaceable></option>. If
	  <option><replaceable>value</replaceable></option> is not
	  provided, returns the value of
	  <option><replaceable>varname</replaceable></option>.
	</para>
      </refsect1>
      <refsect1>
	<title>Example</title>
	  <programlisting>
set foo "bar"
set bee bop
puts "foo is $foo and bee is $bee"
	  </programlisting>
	  <para>Produces:</para>
	  <screen>1
foo is bar and bee is bop
</screen>
      </refsect1>
    </refentry>

     <!-- sort -->
     <refentry xml:id="sort">
      <refnamediv>
	<refname>sort</refname>
	<refpurpose>Sorts list alphabetically.</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>sort</command>
	  <arg choice="req"><replaceable>list</replaceable></arg>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>
	<para>
	  The <command>sort</command> command returns an
	  alphabetically sorted list of the contents of
	  <option><replaceable>list</replaceable></option>.
	</para>
      </refsect1>
      <refsect1>
	<title>Example</title>
	  <programlisting>
puts [sort {padova rovigo verona vicenza venezia treviso belluno}]
	  </programlisting>
	  <para>Produces:</para>
	  <screen>belluno padova rovigo treviso venezia verona vicenza
</screen>
      </refsect1>
    </refentry>

    <!-- split -->
    <refentry xml:id="split">
      <refnamediv>
	<refname>split</refname>
	<refpurpose>Split a string into a list.</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>split</command>
	  <arg choice="req"><replaceable>string</replaceable></arg>
	  <arg choice="opt"><replaceable>splitstring</replaceable></arg>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>
	<para>
	  The <command>split</command> command takes a string and
	  splits it into a list, divided by
	  <option><replaceable>splitstring</replaceable></option>,
	  which defaults to " " if not present.
	</para>
      </refsect1>
      <refsect1>
	<title>Example</title>
	  <programlisting>
puts [split "aaa;bbb;ccc" ";"]
puts [split "aaa bbb ccc"]
puts [split "aaaxbbbycccxyddd" "xy"]
	  </programlisting>
	  <para>Produces:</para>
	  <screen>aaa bbb ccc
aaa bbb ccc
aaaxbbbyccc ddd</screen>
      </refsect1>
    </refentry>

     <refentry xml:id="strbytelen">
      <refnamediv>
	<refname>strbytelen</refname>
	<refpurpose>Return the length of the string, in bytes.</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>strbytelen</command>
	  <arg choice="req"><replaceable>string</replaceable></arg>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>
	<para>
	  The <command>strbytelen</command> returns the length of
	  <option><replaceable>string</replaceable></option>, in
	  bytes.  The number of characters and bytes may be different
	  because of multi byte character encodings.
	</para>
      </refsect1>
    </refentry>

    <refentry xml:id="strcmp">
      <refnamediv>
	<refname>strcmp</refname>
	<refpurpose>Compare two strings, return 0 if equal.</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>strcmp</command>
	  <arg choice="req"><replaceable>stringA</replaceable></arg>
	  <arg choice="req"><replaceable>stringB</replaceable></arg>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>
	<para>
	  The <command>strcmp</command> takes two strings and compares
	  them, returning 0 if they are equal, 1 if the first string
	  is "greater than" the second string, or -1 if the first
	  string is "less than" the second string.
	</para>
      </refsect1>
    </refentry>

    <refentry xml:id="strfind">
      <refnamediv>
	<refname>strfind</refname>
	<refpurpose>Find one string in another.</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>strfind</command>
	  <arg choice="req"><replaceable>string1</replaceable></arg>
	  <arg choice="req"><replaceable>string2</replaceable></arg>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>
	<para>
	  The <command>strfind</command> looks for the first occurence
	  of <replaceable>string1</replaceable> in
	  <replaceable>string2</replaceable>.  If it finds a match, it
	  returns the index where the first letter of the match lies.
	  If it is not found, it returns -1.
	</para>
      </refsect1>
    </refentry>

    <refentry xml:id="strindex">
      <refnamediv>
	<refname>strindex</refname>
	<refpurpose>Return the index'th character of string.</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>strindex</command>
	  <arg choice="req"><replaceable>string</replaceable></arg>
	  <arg choice="req"><replaceable>index</replaceable></arg>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>
	<para>
	  The <command>strindex</command> command returns the
	  <option><replaceable>index</replaceable></option>'th
	  character of <option><replaceable>string</replaceable></option>.
	</para>
      </refsect1>
      <refsect1>
	<title>Example</title>
	  <programlisting>
puts [strindex "Hello, world" 0]
puts [strindex "Hello, world" 11]
	  </programlisting>
	  <para>Produces:</para>
	  <screen>H
d</screen>
      </refsect1>
    </refentry>

    <refentry xml:id="strlast">
      <refnamediv>
	<refname>strlast</refname>
	<refpurpose>Get the last occurance of one string within
	another string</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>strlast</command>
	  <arg choice="req"><replaceable>string</replaceable></arg>
	  <arg choice="req"><replaceable>string_to_search</replaceable></arg>
	  <arg choice="opt"><replaceable>start_index</replaceable></arg>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>

	<para>
	  Search <replaceable>string_to_search</replaceable> for the
	  last place that <replaceable>string</replaceable> occurs,
	  and return the index.  If
	  <replaceable>start_index</replaceable> is provided, start
	  searching from that position.
	</para>
      </refsect1>
    </refentry>

    <!-- strlen -->
    <refentry xml:id="strlen">
      <refnamediv>
	<refname>strlen</refname>
	<refpurpose>String length.</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>strlen</command>
	  <arg choice="req"><replaceable>string</replaceable></arg>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>
	<para>
	  The <command>strlen</command> returns the length of
	  <option><replaceable>string</replaceable></option>.
	</para>
      </refsect1>
      <refsect1>
	<title>Example</title>
	  <programlisting>
puts [strlen "abcdefghijklmnopqrstuvwxyz"]
	  </programlisting>
	  <para>Produces:</para>
	  <screen>26</screen>
      </refsect1>
    </refentry>

    <refentry xml:id="strlower">
      <refnamediv>
	<refname>strlower</refname>
	<refpurpose>Lower case a string</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>strlower</command>
	  <arg choice="req"><replaceable>string</replaceable></arg>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>
	<para>The <command>strlower</command> command returns a
	  lower-cased version of <replaceable>string</replaceable>.</para>
      </refsect1>
    </refentry>

    <refentry xml:id="strrange">
      <refnamediv>
	<refname>strrange</refname>
	<refpurpose>Return a substring from a string</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>strrange</command>
	  <arg choice="req"><replaceable>string</replaceable></arg>
	  <arg choice="req"><replaceable>start</replaceable></arg>
	  <arg choice="req"><replaceable>end</replaceable></arg>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title> 

	<para>The
	  <command>strrange</command> command returns a substring
	  composed of the characters in
	  <replaceable>string</replaceable> from positions
	  <replaceable>start</replaceable> to
	  <replaceable>end</replaceable>.
	</para>
      </refsect1>
    </refentry>

    <refentry xml:id="strrep">
      <refnamediv>
	<refname>strrep</refname>
	<refpurpose>Repeat a string N times</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>strrep</command>
	  <arg choice="req"><replaceable>string</replaceable></arg>
	  <arg choice="req"><replaceable>times</replaceable></arg>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>

	<para>The <command>strrep</command> command returns
	  <replaceable>times</replaceable> copies of
	  <replaceable>string</replaceable>.
	</para>
      </refsect1>
    </refentry>

    <refentry xml:id="strreplace">
      <refnamediv>
	<refname>strreplace</refname>
	<refpurpose>Replace string A in string B</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>strreplace</command>
	  <arg choice="req">
	    <arg choice="req"><replaceable>{from to}</replaceable></arg>
	  </arg>
	  <arg choice="req"><replaceable>string</replaceable></arg>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>

	<para>The <command>strreplace</command> command replaces each instance of
	  <option>from</option> with <option>to</option> in <option>string</option>.
	</para>
      </refsect1>
      <refsect1>
	<title>Example</title>
	  <programlisting>
puts [strreplace {hi hello} blahhiblahblahhihiblah]
	  </programlisting>
	  <para>Produces:</para>
	  <screen>blahhelloblahblahhellohelloblah</screen>
      </refsect1>
    </refentry>


    <refentry xml:id="strtrim">
      <refnamediv>
	<refname>strtrim</refname>
	<refpurpose>Remove whitespace or other characters from the
	beginning/end of a string</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>strtrim</command>
	  <arg choice="req"><replaceable>string</replaceable></arg>
	  <arg choice="opt"><replaceable>totrim</replaceable></arg>
	  <command>strtriml</command>
	  <arg choice="req"><replaceable>string</replaceable></arg>
	  <arg choice="opt"><replaceable>totrim</replaceable></arg>
	  <command>strtrimr</command>
	  <arg choice="req"><replaceable>string</replaceable></arg>
	  <arg choice="opt"><replaceable>totrim</replaceable></arg>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>

	<para>The <command>strtrim</command> command "trims" any
	leading or trailing whitespace from the string passed to it.
	The <command>strtriml</command> and
	<command>strtrimr</command> commands trim from, and only from,
	the left and right sides of the string, respectively.  All of
	the trim commands take an optional argument that specifies
	what exactly to trim.
	</para>
      </refsect1>

      <refsect1>
	<title>Examples</title>
	<screen>
hecl> strtrim " foo "
foo
hecl> strtrim "hello world" "he"
llo world
hecl> strtriml "xxxyyyzzzxxx" xxx
yyyzzzxxx
hecl> strtrim "        alone          "
alone
	</screen>
      </refsect1>
    </refentry>

    <refentry xml:id="strupper">
      <refnamediv>
	<refname>strupper</refname>
	<refpurpose>Upper case a string</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>strupper</command>
	  <arg choice="req"><replaceable>string</replaceable></arg>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>
	<para>
	  The <command>strupper</command> command returns a
	  upper-cased version of <replaceable>string</replaceable>.
	</para>
      </refsect1>
    </refentry>

    <refentry xml:id="system_hasproperty">
      <refnamediv>
	<refname>system.hasproperty</refname>
	<refpurpose>Check for existence of system properties</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>system.hasproperty</command>
	  <arg choice="req"><replaceable>propertyname</replaceable></arg>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>
	<para>
	  Query for the existence of system properties that can be retrieved with the
	  <command>system.getproperty</command> command.
	</para>
      </refsect1>
    </refentry>

    <refentry xml:id="system_getproperty">
      <refnamediv>
	<refname>system.getproperty</refname>
	<refpurpose>Get system properties</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>system.getproperty</command>
	  <arg choice="req"><replaceable>propertyname</replaceable></arg>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>
	<para>
	  Retrieve information about system properties.  Here is a list of some available system
	  properties on Java ME platforms: <link xl:href="http://developers.sun.com/mobility/midp/questions/properties/index.html"></link>
	</para>
      </refsect1>
    </refentry>

    <refentry xml:id="throw">
      <refnamediv>
	<refname>throw</refname>
	<refpurpose>Generates an exception that can be caught with
	  <command>catch</command></refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>throw</command>
	  <arg choice="req"><replaceable>message</replaceable></arg>
	  <arg choice="opt"><replaceable>errortype</replaceable></arg>
	</cmdsynopsis>
      </refsynopsisdiv>

      <refsect1>
	<title>Description</title>
	<para>
	  The <command>throw</command> command generates an exception,
	  that can be caught with the <command>catch
	  command</command>.  <replaceable>message</replaceable> is a
	  human readable error message, whereas
	  <replaceable>errortype</replaceable> is a code that can be
	  matched by code doing a <command>catch</command>.  It can be
	  used as a way for Hecl programs to distinguish between
	  different types of errors in a global catch section of code.
	</para>
      </refsect1>

      <refsect1>
	<title>Examples</title>
	<screen>
hecl> throw "oh no"
{ERROR {oh no}} {throw 1}
hecl> throw "oh no" USERERROR
{USERERROR {oh no}} {throw 1}
	</screen>
      </refsect1>
    </refentry>

    <!-- time -->
    <refentry xml:id="time">
      <refnamediv>
	<refname>time</refname>
	<refpurpose>Time the execution of a script.</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>time</command>
	  <arg choice="req"><replaceable>script</replaceable></arg>
	  <arg choice="opt"><replaceable>repetitions</replaceable></arg>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>
	<para>
	  The <command>time</command> command executes
	  <option><replaceable>script</replaceable></option>
	  <option><replaceable>repetitions</replaceable></option>
	  times, if
	  <option><replaceable>repetitions</replaceable></option> is
	  present, or once if not.  It measures the amount of time
	  taken by this execution in milliseconds, and returns it.
	</para>
      </refsect1>
      <refsect1>
	<title>Example</title>
	  <programlisting>
set time [time {
    set i 0
    while { &lt; $i 100 } {
	incr $i
    }
} 10]
puts "Time is $time"
	  </programlisting>
	  <para>Produces:</para>
	  <screen>Time is 6</screen>
      </refsect1>
    </refentry>

    <refentry xml:id="tnotify">
      <refnamediv>
	<refname>tnotify</refname>
	<refpurpose>Notify a token</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>tnotify</command>
	  <arg choice="req"><replaceable>token</replaceable></arg>
	</cmdsynopsis>
      </refsynopsisdiv>

      <refsect1>
	<title>Description</title>
	<para>
	  The <command>tnotify</command> command notifies a token that is being waited on by the
	  <command>twait</command> command.
	</para>
      </refsect1>

      <refsect1>
	<title>Examples</title>
	<screen>
FIXME
	</screen>
      </refsect1>
    </refentry>


     <!-- true -->
     <refentry xml:id="true">
      <refnamediv>
	<refname>true</refname>
	<refpurpose>Returns true.</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>true</command>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>
	<para>
	  The <command>true</command> command returns 1, or true.
	</para>
      </refsect1>
      <refsect1>
	<title>Example</title>
	  <programlisting>
if { true } {
    puts "true is true"
}
	  </programlisting>
	  <para>Produces:</para>
	  <screen>true is true</screen>
      </refsect1>
    </refentry>

    <refentry xml:id="twait">
      <refnamediv>
	<refname>twait</refname>
	<refpurpose>Wait on a token</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>twait</command>
	  <arg choice="req"><replaceable>token</replaceable></arg>
	</cmdsynopsis>
      </refsynopsisdiv>

      <refsect1>
	<title>Description</title>
	<para>
	  The <command>twait</command> command waits for a token to be "notified" via the
	  <command>tnotify</command> command.  This is useful in situations where you want to return
	  control from a GUI into some other code.
	</para>
      </refsect1>

      <refsect1>
	<title>Examples</title>
	<screen>
FIXME
	</screen>
      </refsect1>
    </refentry>



    <!-- unset -->
    <refentry xml:id="unset">
      <refnamediv>
	<refname>unset</refname>
	<refpurpose>Unset a variable.</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>unset</command>
	  <arg choice="req"><replaceable>varname</replaceable></arg>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>
	<para>
	  The <command>unset</command> command unsets a variable.
	</para>
      </refsect1>
    </refentry>

    <!-- upeval -->
    <refentry xml:id="upeval">
      <refnamediv>
	<refname>upeval</refname>
	<refpurpose>Evaluate script in next stack frame up.</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>upeval</command>
	  <arg choice="opt"><replaceable>level</replaceable></arg>
	  <arg choice="req"><replaceable>script</replaceable></arg>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>
	<para>
	  The <command>upeval</command> command evaluates
	  <option><replaceable>script</replaceable></option> one stack
	  frame up from the current stack frame, if
	  <option><replaceable>level</replaceable></option> is not
	  present.  If
	  <option><replaceable>level</replaceable></option> is
	  present, <command>upeval</command> behaves like so: if
	  <option><replaceable>level</replaceable></option> is less
	  than one, the
	  <option><replaceable>script</replaceable></option> is run
	  that many levels down from the top of the stack.  If it's 0,
	  the script is run at the global level, and if it's a
	  positive number, the script is run at that absolute level up
	  from the global namespace.
	</para>
      </refsect1>
      <refsect1>
	<title>Example</title>
	  <programlisting>
proc stackframe {} {
    upeval { incr $foo }
}
set foo 1
stackframe
puts $foo
	  </programlisting>
	  <para>Produces:</para>
	  <screen>2</screen>
      </refsect1>
    </refentry>

    <!-- while -->
    <refentry xml:id="while">
      <refnamediv>
	<refname>while</refname>
	<refpurpose>While loop.</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>while</command>
	  <arg choice="req"><replaceable>condition</replaceable></arg>
	  <arg choice="req"><replaceable>body</replaceable></arg>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>
	<para>
	  The <command>while</command> command continues to evaluate
	  <option><replaceable>body</replaceable></option> while
	  <option><replaceable>condition</replaceable></option> is true.
	</para>
      </refsect1>
      <refsect1>
	<title>Example</title>
	  <programlisting>
set i 0
while { &lt; $i 6 } {
    puts "i is $i"
    incr $i
}
	  </programlisting>
	  <para>Produces:</para>
	  <screen>i is 0
i is 1
i is 2
i is 3
i is 4
i is 5
</screen>
      </refsect1>
    </refentry>

<!--
     <refentry xml:id="append">
      <refnamediv>
	<refname>append</refname>
	<refpurpose>Append text to a variable.</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<cmdsynopsis>
	  <command>append</command>
	  <arg choice="req"><replaceable>varreference</replaceable></arg>
	  <arg choice="req"><replaceable>string</replaceable></arg>
	</cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
	<title>Description</title>
	<para>
	  The append command takes two arguments, a variable reference, and a string to append to the variable.
	</para>
      </refsect1>
      <refsect1>
	<title>Example</title>
	  <programlisting>
set foo "bar"
append $foo "beebop"
# The foo variable now contains the string barbeebop
	  </programlisting>
	  <para>Produces:</para>
	  <screen>barbeebop</screen>
      </refsect1>
    </refentry>
-->

  </section>

  <section xml:id="extensioncommands">
    <title>Hecl Extension Commands</title>

    <para>
      These commands are available in various Hecl extensions, that
      may or may not be available in different environments.
    </para>

    <section>
      <title>File Interaction</title>
      <para>
	J2ME systems do not always have a file system, so these are not necessarily available.  It
	is possible to compile Hecl with or without these commands.
      </para>
      <note>
	<para>The <command>filefinder</command> command is a bit different from the others, in that
	it is a graphical widget that is used to select files, rather than a command that only
	interacts with the filesystem.</para>
      </note>

      <refentry xml:id="filefinder">
	<refnamediv>
	  <refname>filefinder</refname>
	  <refpurpose>File selection widget.</refpurpose>
	</refnamediv>
	<refsynopsisdiv>
	  <cmdsynopsis>
	    <command>filefinder</command>
	    <arg choice="opt">-startdir <replaceable>start_directory</replaceable></arg>
	    <arg choice="opt">-selectedcmd <replaceable>selected_command</replaceable></arg>
	    <arg choice="opt">-matchcmd <replaceable>match_command</replaceable></arg>
	    <arg choice="opt">-errorcmd <replaceable>error_command</replaceable></arg>
	  </cmdsynopsis>
	</refsynopsisdiv>
	<refsect1>
	  <title>Description</title>
	  <para>
	    Creates a <command>lcdui.list</command> based file selection dialog that lets the user
	    navigate up and down through directories and select a file.  The options are as follows:
	  </para>
	  <itemizedlist>
	    <listitem>
	      <para><option>-startdir</option>: selects the directory to start the search in.</para>
	    </listitem>

	    <listitem>
	      <para><option>-selectedcmd</option>: a <command>proc</command> that by default takes
	      one argument: the name of the selected file.</para>
	    </listitem>
	    <listitem>
	      <para><option>-matchcmd</option>: a <command>proc</command> that takes one argument:
	      the full URL of the file to match against.  If the file is a match, the proc must
	      return a 1, otherwise 0.  If a match occurs, the <option>-selectedcmd</option> will
	      subsequently be called.</para>
	    </listitem>
	    <listitem>
	      <para><option>-errorcmd</option>: a <command>proc</command> that is called with one
	      argument: an error message.  This is called when some error occurs and can be used to
	      display an error message.</para>
	    </listitem>

	  </itemizedlist>
	</refsect1>
      </refentry>


      <refentry xml:id="open">
	<refnamediv>
	  <refname>open</refname>
	  <refpurpose>Opens a file for reading or writing.</refpurpose>
	</refnamediv>
	<refsynopsisdiv>
	  <cmdsynopsis>
	    <command>open</command>
	    <arg choice="req"><replaceable>filename</replaceable></arg>
	    <arg choice="opt">w</arg>
	  </cmdsynopsis>
	</refsynopsisdiv>
	<refsect1>
	  <title>Description</title>
	  <para>
	    Opens <option>filename</option> for reading or writing, depending on whether the
	    <option>w</option> flag is set or not.  The form of <option>filename</option> is
	    platform-dependant.  On Java ME systems, it needs to be a URI.
	  </para>
	</refsect1>
      </refentry>

      <refentry xml:id="source">
	<refnamediv>
	  <refname>source</refname>
	  <refpurpose>Evaluate Hecl script in a file.</refpurpose>
	</refnamediv>
	<refsynopsisdiv>
	  <cmdsynopsis>
	    <command>source</command>
	    <arg choice="req"><replaceable>filename</replaceable></arg>
	  </cmdsynopsis>
	</refsynopsisdiv>
	<refsect1>
	  <title>Description</title>
	  <para>
	    The <command>source</command> command evaluates the Hecl
	    script located in file
	    <option><replaceable>filename</replaceable></option>.
	  </para>
	</refsect1>
	<refsect1>
	  <title>Example</title>
	  <programlisting>
# Variable foo is defined as "Hello world" in foo.hcl
source foo.hcl
puts $foo
	  </programlisting>
	  <para>Produces:</para>
	  <screen>Hello world</screen>
	</refsect1>
      </refentry>

      <refentry xml:id="file_basename">
	<refnamediv>
	  <refname>file.basename</refname>
	  <refpurpose>Returns the file name with no paths.</refpurpose>
	</refnamediv>
	<refsynopsisdiv>
	  <cmdsynopsis>
	    <command>file.basename</command>
	    <arg choice="req"><replaceable>filename</replaceable></arg>
	  </cmdsynopsis>
	</refsynopsisdiv>
	<refsect1>
	  <title>Description</title>
	  <para>
	    Returns the file's name, with no URL schema or paths.
	  </para>
	</refsect1>
	<refsect1>
	  <title>Example</title>
	  <programlisting>file.basename file:///foo/bar/bee/bop.txt</programlisting>
	  <para>Would return</para>
	  <screen>bop.txt</screen>
	</refsect1>
      </refentry>

      <refentry xml:id="file_cd">
	<refnamediv>
	  <refname>file.cd</refname>
	  <refpurpose>Change working directory.</refpurpose>
	</refnamediv>
	<refsynopsisdiv>
	  <cmdsynopsis>
	    <command>file.cd</command>
	    <arg choice="req"><replaceable>directory</replaceable></arg>
	  </cmdsynopsis>
	</refsynopsisdiv>
	<refsect1>
	  <title>Description</title>
	  <para>
	    The <command>cd</command> command changes the current
	    working directory to
	    <option><replaceable>directory</replaceable></option>.  Or
	    at least it changes where <emphasis>Java</emphasis> thinks
	    the working directory is.  It does not change the process'
	    actual working directory.  Apparently that's not possible
	    with Java.
	  </para>
	</refsect1>
      </refentry>

      <refentry xml:id="file_current">
	<refnamediv>
	  <refname>file.current</refname>
	  <refpurpose>Returns the name of the file currently being evaluated.</refpurpose>
	</refnamediv>
	<refsynopsisdiv>
	  <cmdsynopsis>
	    <command>file.current</command>
	  </cmdsynopsis>
	</refsynopsisdiv>
	<refsect1>
	  <title>Description</title>
	  <para>
	    Returns the name of the file currently being evaluated.  For instance, if a file
	    <filename>foobar.hcl</filename> is being sourceed, and there is a call to
	    <command>file.current</command> in it, it will return the name of the file,
	    <filename>foobar.hcl</filename>.
	  </para>
	</refsect1>
      </refentry>

      <refentry xml:id="file_delete">
	<refnamediv>
	  <refname>file.delete</refname>
	  <refpurpose>Delete the file.</refpurpose>
	</refnamediv>
	<refsynopsisdiv>
	  <cmdsynopsis>
	    <command>file.exists</command>
	    <arg choice="req"><replaceable>filename</replaceable></arg>
	  </cmdsynopsis>
	</refsynopsisdiv>
	<refsect1>
	  <title>Description</title>
	  <para>
	    Delete <option>filename</option>.
	  </para>
	</refsect1>
      </refentry>

      <refentry xml:id="file_devs">
	<refnamediv>
	  <refname>file.devs</refname>
	  <refpurpose>List available devices.</refpurpose>
	</refnamediv>
	<refsynopsisdiv>
	  <cmdsynopsis>
	    <command>file.devs</command>
	  </cmdsynopsis>
	</refsynopsisdiv>
	<refsect1>
	  <title>Description</title>
	  <para>
	    Returns a list of the root devices.
	  </para>
	</refsect1>
      </refentry>

      <refentry xml:id="file_du">
	<refnamediv>
	  <refname>file.du</refname>
	  <refpurpose>"Disk" usage.</refpurpose>
	</refnamediv>
	<refsynopsisdiv>
	  <cmdsynopsis>
	    <command>file.du</command>
	    <arg choice="req"><replaceable>filename</replaceable></arg>
	  </cmdsynopsis>
	</refsynopsisdiv>
	<refsect1>
	  <title>Description</title>
	  <para>
	    Returns a hash with the following keys: <constant>total</constant> - the total amount of
	    space on the storage device where the file resides, and <constant>used</constant> - the
	    amount of space currently utilized.
	  </para>
	</refsect1>
      </refentry>

      <refentry xml:id="file_exists">
	<refnamediv>
	  <refname>file.exists</refname>
	  <refpurpose>Does the file exist?</refpurpose>
	</refnamediv>
	<refsynopsisdiv>
	  <cmdsynopsis>
	    <command>file.exists</command>
	    <arg choice="req"><replaceable>filename</replaceable></arg>
	  </cmdsynopsis>
	</refsynopsisdiv>
	<refsect1>
	  <title>Description</title>
	  <para>
	    Returns 1 if the file exists, otherwise 0.
	  </para>
	</refsect1>
      </refentry>

      <refentry xml:id="file_hidden">
	<refnamediv>
	  <refname>file.hidden</refname>
	  <refpurpose>Is the file hidden?</refpurpose>
	</refnamediv>
	<refsynopsisdiv>
	  <cmdsynopsis>
	    <command>file.hidden</command>
	    <arg choice="req"><replaceable>filename</replaceable></arg>
	  </cmdsynopsis>
	</refsynopsisdiv>
	<refsect1>
	  <title>Description</title>
	  <para>
	    Return 1 if the file is "hidden".  To quote from the relevant Java documentation:
	    <blockquote>
	      <para>
		The exact definition of hidden is
		system-dependent. For example, on UNIX systems a file
		is considered to be hidden if its name begins with a
		period character ('.'). On Win32 and FAT file systems,
		a file is considered to be hidden if it has been
		marked as such in the file's attributes. If hidden
		files are not supported on the referenced file system,
		this method always returns false.
	      </para>
	    </blockquote>
	  </para>
	</refsect1>
      </refentry>

      <refentry xml:id="file_isdirectory">
	<refnamediv>
	  <refname>file.isdirectory</refname>
	  <refpurpose>Is this a directory?</refpurpose>
	</refnamediv>
	<refsynopsisdiv>
	  <cmdsynopsis>
	    <command>file.isdirectory</command>
	    <arg choice="req"><replaceable>path</replaceable></arg>
	  </cmdsynopsis>
	</refsynopsisdiv>
	<refsect1>
	  <title>Description</title>
	  <para>
	    Returns 1 if the path in question is a directory, otherwise 0.
	  </para>
	</refsect1>
      </refentry>

      <refentry xml:id="file_isopen">
	<refnamediv>
	  <refname>file.isopen</refname>
	  <refpurpose>Is the file currently in use?</refpurpose>
	</refnamediv>
	<refsynopsisdiv>
	  <cmdsynopsis>
	    <command>file.isopen</command>
	    <arg choice="req"><replaceable>filename</replaceable></arg>
	  </cmdsynopsis>
	</refsynopsisdiv>
	<refsect1>
	  <title>Description</title>
	  <para>
	    Returns 1 if the file is currently open, otherwise 0.
	  </para>
	</refsect1>
      </refentry>

      <refentry xml:id="file_join">
	<refnamediv>
	  <refname>file.join</refname>
	  <refpurpose>Creates a filename from a list.</refpurpose>
	</refnamediv>
	<refsynopsisdiv>
	  <cmdsynopsis>
	    <command>file.join</command>
	    <arg choice="req"><replaceable>list of path elements</replaceable></arg>
	  </cmdsynopsis>
	</refsynopsisdiv>
	<refsect1>
	  <title>Description</title>
	  <para>
	    Given a list of path elements, like {foo bar bee bop}, creates a filename like
	    foo/bar/bee/bop.
	  </para>
	</refsect1>
      </refentry>

      <refentry xml:id="file_list">
	<refnamediv>
	  <refname>file.list</refname>
	  <refpurpose>List files in a directory.</refpurpose>
	</refnamediv>
	<refsynopsisdiv>
	  <cmdsynopsis>
	    <command>file.list</command>
	    <arg choice="req"><replaceable>directory</replaceable></arg>
	  </cmdsynopsis>
	</refsynopsisdiv>
	<refsect1>
	  <title>Description</title>
	  <para>
	    Lists the files in the specified directory.
	  </para>
	</refsect1>
      </refentry>

      <refentry xml:id="file_mkdir">
	<refnamediv>
	  <refname>file.mkdir</refname>
	  <refpurpose>Creates the directory.</refpurpose>
	</refnamediv>
	<refsynopsisdiv>
	  <cmdsynopsis>
	    <command>file.mkdir</command>
	    <arg choice="req"><replaceable>directory</replaceable></arg>
	  </cmdsynopsis>
	</refsynopsisdiv>
	<refsect1>
	  <title>Description</title>
	  <para>
	    Creates the named directory.
	  </para>
	</refsect1>
      </refentry>

      <refentry xml:id="file_mtime">
	<refnamediv>
	  <refname>file.mtime</refname>
	  <refpurpose>Returns the file modification time.</refpurpose>
	</refnamediv>
	<refsynopsisdiv>
	  <cmdsynopsis>
	    <command>file.mtime</command>
	    <arg choice="req"><replaceable>filename</replaceable></arg>
	  </cmdsynopsis>
	</refsynopsisdiv>
	<refsect1>
	  <title>Description</title>
	  <para>
	    Returns the time the file was last modified, as a value expressed in milliseconds since
	    the "epoch" (00:00:00 GMT, January 1, 1970).
	  </para>
	</refsect1>
      </refentry>

      <refentry xml:id="file_readable">
	<refnamediv>
	  <refname>file.readable</refname>
	  <refpurpose>Is the file readable?</refpurpose>
	</refnamediv>
	<refsynopsisdiv>
	  <cmdsynopsis>
	    <command>file.readable</command>
	    <arg choice="req"><replaceable>filename</replaceable></arg>
	  </cmdsynopsis>
	</refsynopsisdiv>
	<refsect1>
	  <title>Description</title>
	  <para>
	    Checks to see whether the file exists and is readable, and if so, returns 1.  Otherwise,
	    returns 0.
	  </para>
	</refsect1>
      </refentry>

      <refentry xml:id="file_rename">
	<refnamediv>
	  <refname>file.rename</refname>
	  <refpurpose>Rename a file.</refpurpose>
	</refnamediv>
	<refsynopsisdiv>
	  <cmdsynopsis>
	    <command>file.rename</command>
	    <arg choice="req"><replaceable>oldname</replaceable></arg>
	    <arg choice="req"><replaceable>newname</replaceable></arg>
	  </cmdsynopsis>
	</refsynopsisdiv>
	<refsect1>
	  <title>Description</title>
	  <para>
	    Renames <option>oldname</option> to <option>newname.</option>
	  </para>
	</refsect1>
      </refentry>

      <refentry xml:id="file_size">
	<refnamediv>
	  <refname>file.size</refname>
	  <refpurpose>Returns the file's size.</refpurpose>
	</refnamediv>
	<refsynopsisdiv>
	  <cmdsynopsis>
	    <command>file.size</command>
	    <arg choice="req"><replaceable>filename</replaceable></arg>
	  </cmdsynopsis>
	</refsynopsisdiv>
	<refsect1>
	  <title>Description</title>
	  <para>
	    Returns <option>filename</option>'s size, in bytes.
	  </para>
	</refsect1>
      </refentry>

      <refentry xml:id="file_split">
	<refnamediv>
	  <refname>file.split</refname>
	  <refpurpose>Return a list of a path's components.</refpurpose>
	</refnamediv>
	<refsynopsisdiv>
	  <cmdsynopsis>
	    <command>file.split</command>
	    <arg choice="req"><replaceable>filename</replaceable></arg>
	  </cmdsynopsis>
	</refsynopsisdiv>
	<refsect1>
	  <title>Description</title>
	  <para>
	    Takes a filename and returns a list of all the file's components.
	  </para>
	</refsect1>
      </refentry>

      <refentry xml:id="file_truncate">
	<refnamediv>
	  <refname>file.truncate</refname>
	  <refpurpose>Truncates the file.</refpurpose>
	</refnamediv>
	<refsynopsisdiv>
	  <cmdsynopsis>
	    <command>file.truncate</command>
	    <arg choice="req"><replaceable>filename</replaceable></arg>
	    <arg choice="req"><replaceable>newlength</replaceable></arg>
	  </cmdsynopsis>
	</refsynopsisdiv>
	<refsect1>
	  <title>Description</title>
	  <para>
	    Truncates the file, making it at most <option>newlength</option> bytes long.
	  </para>
	</refsect1>
      </refentry>

      <refentry xml:id="file_writable">
	<refnamediv>
	  <refname>file.writable</refname>
	  <refpurpose>Is the file writable?</refpurpose>
	</refnamediv>
	<refsynopsisdiv>
	  <cmdsynopsis>
	    <command>file.writable</command>
	    <arg choice="req"><replaceable>filename</replaceable></arg>
	  </cmdsynopsis>
	</refsynopsisdiv>
	<refsect1>
	  <title>Description</title>
	  <para>
	    Checks to see whether the file exists and is writable, and if so, returns 1.  Otherwise,
	    returns 0.
	  </para>
	</refsect1>
      </refentry>

    </section>

    <section xml:id="http_commands">
      <title>HTTP</title>

      <para>
	Even basic J2ME-enabled cell phones can access web pages
	(although they may not be able to create TCP/IP sockets).  Hecl
	provides basic http commands</para>

      <refentry xml:id="http_geturl">
	<refnamediv>
	  <refname>http.geturl</refname>
	  <refpurpose>Fetch contents of a URL.</refpurpose>
	</refnamediv>
	<refsynopsisdiv>
	  <cmdsynopsis>
	    <command>http.geturl</command>
	    <arg choice="req"><replaceable>url</replaceable></arg>
	    <arg choice="opt">-query <replaceable>POSTdata</replaceable></arg>
	    <arg choice="opt">-headers <replaceable>list of headers</replaceable></arg>
	    <arg choice="opt">-validate [1|0]</arg>
	  </cmdsynopsis>
	</refsynopsisdiv>
	<refsect1>
	  <title>Description</title>
	  <para>
	    The <command>http.geturl</command> command performs an HTTP request to the given
	    <option><replaceable>url</replaceable></option> and returns information about the
	    results.  This information is returned as a hash table that can be accessed with the
	    various h* commands such as <command>hget</command>.  The list of keys returned includes
	    the following, which are set by Hecl.  Also created as keys are the various HTTP
	    headers, such as connection, content-length, content-type, last-modified, and so on.
	  </para>
	  <itemizedlist>
	    <listitem>
	      <para><constant>binary</constant>: 1 if the data
		returned is binary, otherwise 0.</para></listitem>

	    <listitem>
	      <para><constant>charset</constant>: The charset used for
		the returned data.</para></listitem>

	    <listitem>
	      <para><constant>data</constant>: The returned data.  For instance, if you fetched an
	      ordinary web page, this would be its HTML contents.</para>
	    </listitem>

	    <listitem>
	      <para><constant>ncode</constant>: The numeric code of
		the response, such as 404, 500, 301, and so on.</para></listitem>

	    <listitem>
	      <para><constant>status</constant>: The request status -
		ok if the request was successfully processed.
	      </para>
	    </listitem>
	  </itemizedlist>
	  <para>
	    The <option>-query</option> option is used to send
	    key/value pairs of variables.  In order to set random
	    headers, the <option>-headers</option> argument is used.
	    The <option>-validate</option> option exists to send a
	    <constant>HEAD</constant> request.
	  </para>
	</refsect1>
	<refsect1>
	  <title>Example</title>
	  <programlisting>
# Evaluate Hecl script located on a web site.
eval [hget [http.geturl http://www.hecl.org/somescript.hcl] data]
	  </programlisting>
	  <para>Add some headers to a request:</para>
	  <programlisting>
http.geturl http://www.hecl.org/ -headers {Set-Cookie foo=bar}
	  </programlisting>

	</refsect1>
      </refentry>

      <refentry xml:id="http_formatQuery">
	<refnamediv>
	  <refname>http.formatQuery</refname>
	  <refpurpose>URL Encode a request</refpurpose>
	</refnamediv>
	<refsynopsisdiv>
	  <cmdsynopsis>
	    <command>http.formatQuery</command>
	    <arg choice="opt"><replaceable>key</replaceable>
	    <replaceable>val</replaceable></arg>
	  </cmdsynopsis>
	</refsynopsisdiv>
	<refsect1>
	  <title>Description</title>
	  <para>The <command>http.formatQuery</command> command takes
	  a series of key value pairs and urlencodes them.  Useful in
	    order to pass data to the <option>-query</option> option
	    of <command>http.geturl</command></para>
	</refsect1>
      </refentry>

      <refentry xml:id="http_data">
	<refnamediv>
	  <refname>http.data</refname>
	  <refpurpose>A shortcut to get the data from an http.geturl response.</refpurpose>
	</refnamediv>
	<refsynopsisdiv>
	  <cmdsynopsis>
	    <command>http.data</command>
	    <arg choice="req"><replaceable>request</replaceable></arg>
	  </cmdsynopsis>
	</refsynopsisdiv>
	<refsect1>
	  <title>Description</title>
	  <para>
	    The <command>http.data</command> command is equivalent to
	    an <command>hget</command> with <constant>data</constant>
	    as the key.
	  </para>
	  <programlisting>http.data [http.geturl http://www.dedasys.com]</programlisting>
	</refsect1>
      </refentry>

      <refentry xml:id="http_ncode">
	<refnamediv>
	  <refname>http.ncode</refname>
	  <refpurpose>A shortcut to get the numeric code from an http.geturl response.</refpurpose>
	</refnamediv>
	<refsynopsisdiv>
	  <cmdsynopsis>
	    <command>http.ncode</command>
	    <arg choice="req"><replaceable>request</replaceable></arg>
	  </cmdsynopsis>
	</refsynopsisdiv>
	<refsect1>
	  <title>Description</title>
	  <para>
	    The <command>http.data</command> command is equivalent to
	    an <command>hget</command> with <constant>ncode</constant>
	    as the key.
	  </para>
	  <programlisting>http.ncode [http.geturl http://www.dedasys.com]</programlisting>
	</refsect1>
      </refentry>

      <refentry xml:id="http_status">
	<refnamediv>
	  <refname>http.status</refname>
	  <refpurpose>A shortcut to get the status from an http.geturl response.</refpurpose>
	</refnamediv>
	<refsynopsisdiv>
	  <cmdsynopsis>
	    <command>http.status</command>
	    <arg choice="req"><replaceable>request</replaceable></arg>
	  </cmdsynopsis>
	</refsynopsisdiv>
	<refsect1>
	  <title>Description</title>
	  <para>
	    The <command>http.status</command> command is equivalent to
	    an <command>hget</command> with <constant>status</constant>
	    as the key.
	  </para>
	  <programlisting>http.status [http.geturl http://www.dedasys.com]</programlisting>
	</refsect1>
      </refentry>

    </section>

    <section xml:id="location_commands">
      <title>Location</title>
      <para>
	Access to your phone's location API (JSR 179).  Get information on your precise location.
	<note>
	<para>Not available on all phones.</para>
	</note>
      </para>

      <refentry xml:id="location_get">
	<refnamediv>
	  <refname>location.get</refname>
	  <refpurpose>Get location information.</refpurpose>
	</refnamediv>
	<refsynopsisdiv>
	  <cmdsynopsis>
	    <command>location.get</command>
	    <group choice="req">
	      <arg choice="req"><replaceable>timeout</replaceable></arg>
	      <arg choice="req">
		<arg choice="req">-callback</arg>
		<arg choice="req"><replaceable>callbackProc</replaceable></arg>
		<arg choice="opt">
		  <arg choice="req">-timeout</arg>
		  <arg choice="req"><replaceable>timeout</replaceable></arg>
		</arg>
		<arg choice="opt">
		  <arg choice="req">-onerror</arg>
		  <arg choice="req"><replaceable>onErrorProc</replaceable></arg>
		</arg>
	      </arg>
	    </group>
	  </cmdsynopsis>
	</refsynopsisdiv>
	<refsect1>
	  <title>Description</title>
	  <para>
	    The <command>location.get</command> command operates in two ways:
	  </para>
	  <orderedlist>
	    <listitem>
	      <para>
		The simplest way is to simply call the command with a
		<option>timeout</option> argument.  The program will block until
		the command returns an answer, in the form of a hash table (see
		below), which could take up to several minutes.
	      </para>
	    </listitem>
	    <listitem>
	      <para>
		The alternative way of calling
		<command>location.get</command> is to pass it a
		<option>-callback
		<replaceable>callbackProc</replaceable></option>,
		which is the name of a proc that will be called when
		the information is available, with a hash table
		specifying the results.  Program execution continues
		and does not block on the location.get call.  The
		<option>callbackProc</option> takes one argument,
		which is a hash of information about the location.
		When using <option>-callback</option> it is also
		possible to specify a <option>-timeout</option> option
		(in seconds), and an <option>-onerror</option> option.
		This is used in case of errors: the specified
		<option><replaceable>onErrorProc</replaceable></option>
	      </para>
	    </listitem>
	  </orderedlist>
	  <para>
	    Either method will supply the user with a hash table with the
	    following elements.  See also the JavaDocs here:
	    <link xl:href="http://library.forum.nokia.com/index.jsp?topic=/Java_Developers_Library/GUID-4AEC8DAF-DDCC-4A30-B820-23F2BA60EA52/javax/microedition/location/Location.html">javax/microedition/location/Location</link>
	  </para>
	  <itemizedlist>
	    <listitem>
	      <para>
		<constant>lat</constant>: latitude.
	      </para>
	    </listitem>

	    <listitem>
	      <para>
		<constant>lon</constant>: longitude.
	      </para>
	    </listitem>
	    <listitem>
	      <para>
		<constant>alt</constant>: altitude.
	      </para>
	    </listitem>
	    <listitem>
	      <para>
		<constant>haccuracy</constant>: horizontal accuracy, in meters.
	      </para>
	    </listitem>
	    <listitem>
	      <para>
		<constant>vaccuracy</constant>: vertical accuracy, in meters.
	      </para>
	    </listitem>
	    <listitem>
	      <para>
		<constant>location_method</constant>: contains a hash table of
		its own with information about the method used to ascertain the
		location.  Possible values include:
	      </para>

	      <itemizedlist>
		<listitem>
		  <para><constant>ASSISTED</constant>: Location method is assisted.</para>
		</listitem>
		<listitem>
		  <para><constant>UNASSISTED</constant>: Location method is unassisted.</para>
		</listitem>
		<listitem>
		  <para><constant>NETWORKBASED</constant>: Location is derived
		  from the network.</para>
		</listitem>
		<listitem>
		  <para><constant>TERMINALBASED</constant>: Location is obtained
		  from a GPS terminal.</para>
		</listitem>
		<listitem>
		  <para><constant>ANGLEOFARRIVAL</constant>: Location method
		  Angle of Arrival for cellular / terrestrial RF system.</para>
		</listitem>
		<listitem>
		  <para><constant>CELLID</constant>: Location method Cell-ID for
		  cellular (in GSM, this is the same as CGI, Cell Global
		  Identity).</para>
		</listitem>
		<listitem>
		  <para><constant>SATELLITE</constant>: Location method using
		  satellites (for example, Global Positioning System
		  (GPS)).</para>
		</listitem>
		<listitem>
		  <para><constant>SHORTRANGE</constant>: Location method
		  Short-range positioning system (for example, Bluetooth
		  LP).</para>
		</listitem>
		<listitem>
		  <para><constant>TIMEDIFFERENCE</constant>: Location method
		  Time Difference for cellular / terrestrial RF system (for
		  example, Enhanced Observed Time Difference (E-OTD) for
		  GSM).</para>
		</listitem>
		<listitem>
		  <para><constant>TIMEOFARRIVAL</constant>: Location method Time
		  of Arrival (TOA) for cellular / terrestrial RF system.</para>
		</listitem>
	      </itemizedlist>

	    </listitem>
	    <listitem>
	      <para>
		<constant>speed</constant>: ground speed, in meters per second.
	      </para>
	    </listitem>
	    <listitem>
	      <para>
		<constant>course</constant>: course, in degrees relative to true
		north.
	      </para>
	    </listitem>

	  </itemizedlist>
	</refsect1>
      </refentry>

    </section>

    <section xml:id="networking_commands">
      <title>Net</title>

      <para>Networking commands</para>

      <refentry xml:id="base64_decode">
	<refnamediv>
	  <refname>base64::decode</refname>
	  <refpurpose>Base 64 decode</refpurpose>
	</refnamediv>
	<refsynopsisdiv>
	  <cmdsynopsis>
	    <command>base64::decode</command>
	    <arg choice="req"><replaceable>encoded-data</replaceable></arg>
	  </cmdsynopsis>
	</refsynopsisdiv>
	<refsect1>
	  <title>Description</title>
	  <para>
	    The <command>base64::decode</command> command does a
	    base64 decode of the string passed to it.
	  </para>
	</refsect1>
      </refentry>

      <refentry xml:id="base64_encode">
	<refnamediv>
	  <refname>base64::encode</refname>
	  <refpurpose>Base 64 encode</refpurpose>
	</refnamediv>
	<refsynopsisdiv>
	  <cmdsynopsis>
	    <command>base64::encode</command>
	    <arg choice="req"><replaceable>data</replaceable></arg>
	  </cmdsynopsis>
	</refsynopsisdiv>
	<refsect1>
	  <title>Description</title>
	  <para>
	    The <command>base64::encode</command> command does a
	    base64 encode of the string passed to it.
	  </para>
	</refsect1>
      </refentry>


    </section>

    <section xml:id="recordstore_commands">
      <title>RecordStore</title>

      <para>
	Record Store is the name for persistent storage in J2ME.  Even
	simple MIDP1.0 phones have this feature, and utilize it to
	store data between invocations of the application.
      </para>

      <refentry xml:id="rms_list">
	<refnamediv>
	  <refname>rms.list</refname>
	  <refpurpose>
	    List available record store names, or id's for a
	    name.</refpurpose>
	</refnamediv>
	<refsynopsisdiv>
	  <cmdsynopsis>
	    <command>rms.list</command>
	    <arg choice="opt"><replaceable>rsname</replaceable></arg>
	  </cmdsynopsis>
	</refsynopsisdiv>
	<refsect1>
	  <title>Description</title>
	  <para>
	    The <command>rms.list</command> command, when called
	    without arguments, returns a list of names of the
	    available record stores that have already been created.
	    When called with an <option><replaceable>record store
	    name</replaceable></option> returns the list of id's that
	    are currently in use for that record store.
	  </para>
	</refsect1>
	<refsect1>
	  <title>Example</title>
	  <programlisting>
foreach name [rs.list] {
    puts "Listing of id's for $name :"
    puts [rs.list $name]
}
	  </programlisting>
	  <para>Produces:</para>
	  <screen>yyy</screen>
	</refsect1>
      </refentry>

      <refentry xml:id="rms_size">
	<refnamediv>
	  <refname>rms.size</refname>
	  <refpurpose>Returns the size occupied by the record store</refpurpose>
	</refnamediv>
	<refsynopsisdiv>
	  <cmdsynopsis>
	    <command>rms.size</command>
	    <arg choice="req"><replaceable>rsname</replaceable></arg>
	  </cmdsynopsis>
	</refsynopsisdiv>
	<refsect1>
	  <title>Description</title>
	  <para>
	    The <command>rms.size</command> command returns the size,
	    in bytes, occupied by the recordstore specified.
	  </para>
	</refsect1>
      </refentry>

      <refentry xml:id="rms_sizeavail">
	<refnamediv>
	  <refname>rms.sizeavail</refname>
	  <refpurpose>Returns the amount of space available to grow
	  for this record store.</refpurpose>
	</refnamediv>
	<refsynopsisdiv>
	  <cmdsynopsis>
	    <command>rms.sizeavail</command>
	    <arg choice="req"><replaceable>filename</replaceable></arg>
	  </cmdsynopsis>
	</refsynopsisdiv>
	<refsect1>
	  <title>Description</title>
	  <para>
	    The <command>rms.sizeavail</command> command returns the
	    size in bytes left to grow for the specified recordstore.
	  </para>
	</refsect1>
      </refentry>

      <refentry xml:id="rms_set">
	<refnamediv>
	  <refname>rms.set</refname>
	  <refpurpose>Sets the value of a record store</refpurpose>
	</refnamediv>
	<refsynopsisdiv>
	  <cmdsynopsis>
	    <command>rms.set</command>
	    <arg choice="req"><replaceable>rsname</replaceable></arg>
	    <arg choice="opt"><replaceable>recordid</replaceable></arg>
	    <arg choice="req"><replaceable>data</replaceable></arg>
	  </cmdsynopsis>
	</refsynopsisdiv>
	<refsect1>
	  <title>Description</title>
	  <para>
	    The <command>rms.set</command> command takes, as
	    arguments, the name of the record store; optionally, the
	    record id to set, and finally, the data to insert into the
	    record store.  If the record id is not specified, the
	    default value of 1 is used.
	  </para>
	</refsect1>
      </refentry>

      <refentry xml:id="rms_get">
	<refnamediv>
	  <refname>rms.get</refname>
	  <refpurpose>Fetch the value of the specified record store
	  and record id</refpurpose>
	</refnamediv>
	<refsynopsisdiv>
	  <cmdsynopsis>
	    <command>rms.get</command>
	    <arg choice="req"><replaceable>rsname</replaceable></arg>
	    <arg choice="opt"><replaceable>recordid</replaceable></arg>
	  </cmdsynopsis>
	</refsynopsisdiv>
	<refsect1>
	  <title>Description</title>
	  <para>
	    The <command>rms.get</command> command returns the value
	    of the data stored in record store
	    <option><replaceable>rsname</replaceable></option>.  The
	    optional argument
	    <option><replaceable>recordid</replaceable></option>
	    specifies the record id, and defaults to 1.  An error is
	    thrown if the record does not exist.
	  </para>
	</refsect1>
	<refsect1>
	  <title>Example</title>
	  <programlisting>
rms.set highscore 1 [highscore]
... application restarted ...
set highscore [rms.get highscore 1]
	  </programlisting>
	</refsect1>
      </refentry>

      <refentry xml:id="rms_add">
	<refnamediv>
	  <refname>rms.add</refname>
	  <refpurpose>Adds data to the specified record store,
	  returning the new record id.</refpurpose>
	</refnamediv>
	<refsynopsisdiv>
	  <cmdsynopsis>
	    <command>rms.add</command>
	    <arg choice="req"><replaceable>data</replaceable></arg>
	  </cmdsynopsis>
	</refsynopsisdiv>
	<refsect1>
	  <title>Description</title>
	  <para>
	    The <command>rms.add</command> command adds
	    <option><replaceable>data</replaceable></option> to the
	    named record store, returning the record id with which it
	    may be retrieved in the future.
	  </para>
	</refsect1>
      </refentry>

      <refentry xml:id="rms_delete">
	<refnamediv>
	  <refname>rms.delete</refname>
	  <refpurpose>Deletes either the record store, or a record id
	  associated with a record store.</refpurpose>
	</refnamediv>
	<refsynopsisdiv>
	  <cmdsynopsis>
	    <command>rms.delete</command>
	    <arg choice="req"><replaceable>rsname</replaceable></arg>
	    <arg choice="opt"><replaceable>recordid</replaceable></arg>
	  </cmdsynopsis>
	</refsynopsisdiv>
	<refsect1>
	  <title>Description</title>
	  <para>
	    The <command>rms.delete</command> command deletes either
	    the entire record store, if a <option><replaceable>record
	    id</replaceable></option> is not specified, or if one is,
	    the record id in question.
	  </para>
	</refsect1>
      </refentry>

      <refentry xml:id="rms_hset">
	<refnamediv>
	  <refname>rms.hset</refname>
	  <refpurpose>Sets a key/value pair in the given record store.</refpurpose>
	</refnamediv>
	<refsynopsisdiv>
	  <cmdsynopsis>
	    <command>rms.hset</command>
	    <arg choice="req"><replaceable>rsname</replaceable></arg>
	    <arg choice="req"><replaceable>key</replaceable></arg>
	    <arg choice="req"><replaceable>value</replaceable></arg>
	  </cmdsynopsis>
	</refsynopsisdiv>
	<refsect1>
	  <title>Description</title>
	  <para>
	    The <command>rms.hset</command> command, given the name of
	    a record store
	    <option><replaceable>rsname</replaceable></option> treats
	    it as a hash table, setting the value of
	    <option><replaceable>key</replaceable></option> with
	    <option><replaceable>data</replaceable></option>.
	  </para>
	</refsect1>
      </refentry>

      <refentry xml:id="rms_hget">
	<refnamediv>
	  <refname>rms.hget</refname>
	  <refpurpose>Gets the value of a given key in the specified
	  record store</refpurpose>
	</refnamediv>
	<refsynopsisdiv>
	  <cmdsynopsis>
	    <command>rms.hget</command>
	    <arg choice="req"><replaceable>rsname</replaceable></arg>
	    <arg choice="req"><replaceable>key</replaceable></arg>
	  </cmdsynopsis>
	</refsynopsisdiv>
	<refsect1>
	  <title>Description</title>
	  <para>
	    The <command>rms.hget</command> command returns the data
	    associated with
	    <option><replaceable>key</replaceable></option> in the
	    named record store.
	  </para>
	</refsect1>
      </refentry>

      <refentry xml:id="rms_hexists">
	<refnamediv>
	  <refname>rms.hexists</refname>
	  <refpurpose>Determine whether a given key exists in a record
	  store.</refpurpose>
	</refnamediv>
	<refsynopsisdiv>
	  <cmdsynopsis>
	    <command>rms.hexists</command>
	    <arg choice="req"><replaceable>rsname</replaceable></arg>
	    <arg choice="req"><replaceable>key</replaceable></arg>
	  </cmdsynopsis>
	</refsynopsisdiv>
	<refsect1>
	  <title>Description</title>
	  <para>
	    The <command>rms.hexists</command> command returns 1 if
	    the given <option><replaceable>key</replaceable></option>
	    exists in the named record store.
	  </para>
	</refsect1>
      </refentry>

      <refentry xml:id="rms_hkeys">
	<refnamediv>
	  <refname>rms.hkeys</refname>
	  <refpurpose>Returns all keys associated with a given record store.</refpurpose>
	</refnamediv>
	<refsynopsisdiv>
	  <cmdsynopsis>
	    <command>rms.hkeys</command>
	    <arg choice="req"><replaceable>rsname</replaceable></arg>
	  </cmdsynopsis>
	</refsynopsisdiv>
	<refsect1>
	  <title>Description</title>
	  <para>
	    The <command>rms.hkeys</command> command returns a list of
	    keys associated with the named record store.
	  </para>
	</refsect1>
      </refentry>

      <refentry xml:id="rms_hdel">
	<refnamediv>
	  <refname>rms.hdel</refname>
	  <refpurpose>Deletes a key from the specified record store.</refpurpose>
	</refnamediv>
	<refsynopsisdiv>
	  <cmdsynopsis>
	    <command>rms.hdel</command>
	    <arg choice="req"><replaceable>rsname</replaceable></arg>
	    <arg choice="req"><replaceable>key</replaceable></arg>
	  </cmdsynopsis>
	</refsynopsisdiv>
	<refsect1>
	  <title>Description</title>
	  <para>
	    The <command>rms.hdel</command> command deletes
	    <option><replaceable>key</replaceable></option> from
	    record store
	    <option><replaceable>rsname</replaceable></option>.
	  </para>
	</refsect1>
      </refentry>
    </section>

    <section xml:id="kxml">
        <title>K-XML</title>
        <para>
	  The K-XML extension provides the kXML 2 parser functionality for hecl. kXML 2 implements
	  the XmlPull API. Please find general information about XmlPull parsers including the
	  interface documentation at <link xl:href="xmlpull.org">xmlpull.org</link>.
      </para>
      <note>
	<para>
	  Kxml is not compiled into the default build, so you have to change the
	  <property>kxml</property> property from 0 to 1 in the
	  <filename>cldc11midp20.properties</filename> file and recompile Hecl.
	</para>
      </note>
        <refentry xml:id="kxml.create">
            <refnamediv>
                <refname>kxml.create</refname>
                <refpurpose>Returns the kxml parser object.</refpurpose>
            </refnamediv>
            <refsynopsisdiv>
                <cmdsynopsis>
                    <command>kxml.create</command>
                </cmdsynopsis>
            </refsynopsisdiv>
            <refsect1>
                <title>Description</title>
                <para>
                The <command>kxml.create </command>creates a kxml parser object.</para>
                <programlisting>
set xmlParser [kxml.create]
                </programlisting>
            </refsect1>
        </refentry>

      <refentry xml:id="kxml.gettext">
	<refnamediv>
	  <refname>kxml.gettext</refname>
	  <refpurpose>Returns the text content of the current event as a string.</refpurpose>
	</refnamediv>
	<refsynopsisdiv>
	  <cmdsynopsis>
	    <command>kxml.gettext</command>
	  </cmdsynopsis>
	</refsynopsisdiv>
	<refsect1>
	  <title>Description</title>
	  <para>
	    The <command>kxml.gettext</command> returns the text content of the current XML event as
	    a string.
	  </para>
	  <para>
	    The value returned depends on current event type, for example for TEXT event it is
	    element content (this is typical case when <command>kxml.next</command> is used). See
	    description of <command>kxml.nextToken</command> for detailed description of possible
	    returned values for different types of events.
	  </para>
	  <para>
	    <note>
	      <para>
		In case of ENTITY_REF, this method returns the entity
		replacement text (or an empty string if not
		available).
	      </para>
	    </note>
	  </para>
	</refsect1>
      </refentry>


        <refentry xml:id="kxml.input">
            <refnamediv>
                <refname>kxml.input</refname>
                <refpurpose>Sets a input stream the kxml-parser is going to process.</refpurpose>
            </refnamediv>
            <refsynopsisdiv>
                <cmdsynopsis>
                    <command>kxml.input</command>
                    <arg choice="req">
                    <replaceable>xmlParser</replaceable></arg>
                    
                    <arg choice="req">
                    <replaceable>xmlStream</replaceable></arg>
                </cmdsynopsis>
                
            </refsynopsisdiv>
            <refsect1>
                <title>Description</title>
                <para>Set the xml input stream to the given xmlParser.</para>
                <programlisting>
set http [http.geturl "http://www.google.com/ig/api?weather=$city,$country"]
set xmlStream [hget $http data]
kxml.input $xmlParser $xmlStream
                </programlisting>
            </refsect1>
        </refentry>
        <refentry xml:id="kxml.nexttag">
            <refnamediv>
                <refname>kxml.nexttag</refname>
                <refpurpose>Call <command>kxml.next</command> and return event if it is START_TAG or END_TAG otherwise throw an exception.</refpurpose>
            </refnamediv>
            <refsynopsisdiv>
                <cmdsynopsis>
                    <command>kxml.nexttag</command>
                    <arg choice="req">
                    <replaceable>xmlParser</replaceable></arg>
                </cmdsynopsis>
            </refsynopsisdiv>
            
            <refsect1>
                <title>Description</title>
                <para>Call <command>kxml.nexttag</command> and return event if it is START_TAG or END_TAG otherwise throw an exception.It will skip whitespace TEXT before actual tag if any.</para>
            </refsect1>
        </refentry>
        <refentry xml:id="kxml.next">
            <refnamediv>
                <refname>kxml.next</refname>
                <refpurpose>Get next parsing event.</refpurpose>
            </refnamediv>
            <refsynopsisdiv>
                <cmdsynopsis>
                    <command>kxml.next</command>
                    <arg choice="req">
                    <replaceable>xmlParser</replaceable></arg>
                </cmdsynopsis>
            </refsynopsisdiv>
            
            <refsect1>
                <title>Description</title>
                <para>The <command> kxml.next </command> advance the parser to the next event. The int value returned from next determines the current parser state and is identical to the value returned from following calls to <command>kxml.event</command>.
                </para>
                <para>The following event types are seen by <command>kxml.next</command> .</para>
                <itemizedlist>
                    <listitem>
                        <para><constant>START_DOCUMENT</constant> <constant>0</constant> :Initially, the parser is in the START_DOCUMENT  state.
                        </para>
                    </listitem>
                    <listitem>
                        <para><constant>START_TAG</constant> <constant>2</constant>: An XML start tag was read.
                        </para>
                    </listitem>
                    <listitem>
                        <para><constant>TEXT</constant> <constant>4</constant>: Text content was read; the text content can be retreived using the <command>kxml.gettext</command> method.
                        </para>
                    </listitem>
                    <listitem>
                        <para><constant>END_TAG</constant> <constant>3</constant>: An end tag was read.
                        </para>
                    </listitem>
                    <listitem>
                        <para><constant>END_DOCUMENT</constant> <constant>1</constant>: No more events are available.
                        </para>
                    </listitem>
                </itemizedlist>
            </refsect1>
        </refentry>
        <refentry xml:id="kxml.requirestart">
            <refnamediv>
                <refname>kxml.requirestart</refname>
                <refpurpose>Test if the current event is START_TAG type and do match the given name.</refpurpose>
            </refnamediv>
	    <refsynopsisdiv>
	      <cmdsynopsis>
		<command>kxml.requirestart</command>
		<arg choice="req">
		<replaceable>xmlParser</replaceable></arg>
		<arg choice="req">
		<replaceable>name</replaceable></arg>
	      </cmdsynopsis>
	    </refsynopsisdiv>
            <refsect1>
                <title>Description</title>
                <para>Test if the current event is START_TAG type do match the given name and any namesapce. If the test is not passed, an exception is thrown. The exception text indicates the parser position, the expected event and the current event that is not meeting the requirement.
		</para>
                <programlisting>
# assert the current event is a START_TAG event "forecast_conditions"
kxml.requirestart $xmlParser "forecast_conditions"
                </programlisting>
            </refsect1>
        </refentry>
        <refentry xml:id="kxml.requireend">
            <refnamediv>
                <refname>kxml.requireend</refname>
                <refpurpose>Test if the current event is END_TAG type and do match the given name.</refpurpose>
            </refnamediv>
	    <refsynopsisdiv>
	      <cmdsynopsis>
		<command>kxml.requireend</command>
		<arg choice="req">
		<replaceable>xmlParser</replaceable></arg>
		<arg choice="req">
		<replaceable>name</replaceable></arg>
	      </cmdsynopsis>
	    </refsynopsisdiv>
            <refsect1>
                <title>Description</title>
                <para>Test if the current event is END_TAG type and do match the given name and any namespace. If the test is not passed, an exception is thrown. The exception text indicates the parser position, the expected event and the current event that is not meeting the requirement.</para>
                <programlisting>
# assert we have reach the END_TAG event of "forecast_conditions"
kxml.requireend $xmlParser "forecast_conditions"
                </programlisting>
            </refsect1>
        </refentry>
        <refentry xml:id="kxml.attrcount">
            <refnamediv>
                <refname>kxml.attrcount</refname>
                <refpurpose>Returns the number of attributes of the current start tag.</refpurpose>
            </refnamediv>
	    <refsynopsisdiv>
	      <cmdsynopsis>
		<command>kxml.attrcount</command>
		<arg choice="req">
		<replaceable>xmlParser</replaceable></arg>
	      </cmdsynopsis>
	    </refsynopsisdiv>
            <refsect1>
	      <title>Description</title>
	      <para>Returns the number of attributes of the current start tag, or -1 if the current event type is not START_TAG. </para>
            </refsect1>
        </refentry>
        <refentry xml:id="kxml.attrvalue">
            <refnamediv>
                <refname>kxml.attrvalue</refname>
                <refpurpose>Returns the given attributes value.</refpurpose>
            </refnamediv>
	    <refsynopsisdiv>
	      <cmdsynopsis>
		<command>kxml.attrvalue</command>
		<arg choice="req">
		<replaceable>xmlParser</replaceable></arg>
		<arg choice="req">
		<replaceable>index</replaceable></arg>
	      </cmdsynopsis>
	    </refsynopsisdiv>
            <refsect1>
                <title>Description</title>
                <para>Returns the given attributes value.</para>
            </refsect1>
        </refentry>
        <refentry xml:id="kxml.getname">
            <refnamediv>
                <refname>kxml.getname</refname>
                <refpurpose> For START_TAG or END_TAG events, the name of the current element is returned.</refpurpose>
            </refnamediv>
	    <refsynopsisdiv>
	      <cmdsynopsis>
		<command>kxml.getname</command>
		<arg choice="req">
		<replaceable>xmlParser</replaceable></arg>
	      </cmdsynopsis>
	    </refsynopsisdiv>
            <refsect1>
	      <title>Description</title>
	      <para>For START_TAG or END_TAG events, the name of the current element is returned.</para>
	      <programlisting>
# loop over the stream until we reach the END_TAG event "current_conditions"
while {!= [strcmp [kxml.getname $xmlParser] "current_conditions"] 0 } {
    set name [kxml.getname $xmlParser]
    puts $name
    kxml.nexttag $xmlParser
}
	      </programlisting>
            </refsect1>
        </refentry>
    </section>

  </section>


  <section xml:id="heclandjava">
    <title>Interfacing Hecl and Java</title>

    <para>
      Hecl is not a replacement for Java, and is indeed meant to work hand in hand with Java.  We
      attempt to make it as easy as possible to call Java from Hecl, via the creation of new Hecl
      commands that can call Java code, in addition to calling Hecl from Java, which is a matter of
      a few lines of code.
      </para>

    <section>
      <title>Calling Hecl code from Java</title>

      <programlisting>
import org.hecl.files.HeclFile;

import org.hecl.Eval;
import org.hecl.Interp;
import org.hecl.Thing;
import org.hecl.ListThing;
import org.hecl.HeclException;

...

	try {
	    /* First, create a new interpreter, and pass it a
	     * mechanism to load resources with - in this case,
	     * files. */
	    Interp interp = new Interp();

	    /* Add the files package  */
	    new HeclFile().loadModule(interp);
	    /* Evaluate the file at args[0] */
	    HeclFile.sourceFile(interp, args[0]);
	    /* Evaluate some code in a string.  */
	    String helloworld = new String("puts {Hello, world!}");
	    interp.eval(new Thing(helloworld));
	} catch (Exception e) {
	    System.err.println(e);
	}
      </programlisting>

      <para>
	The above code first creates a new interpreter.  Next, it
	instantiates the HeclFile system.  This isn't part of the Hecl
	core, because some systems, like J2ME, may not have files.  If
	you don't have files, you can still use
	<methodname>interp.eval</methodname> to evaluate some code,
	which could come from whatever source you desire.
      </para>
    </section>

    <section xml:id="creating_new_hecl_commands">
      <title>Creating new Hecl commands</title>

      <para>
	Creating new Hecl commands is relatively simple.  The first step is to create a new class
	for your command in a file, say <filename>HelloCmd.java</filename>, which, for simplicity's
	sake, you could put in <filename>core/org/hecl/</filename>.  The code would look something
	like this:
      </para>

      <programlisting>
import org.hecl.Command;
import org.hecl.HeclException;
import org.hecl.Interp;
import org.hecl.Thing;

class HelloCmd implements Command {

    public Thing cmdCode(Interp interp, Thing[] argv)
	throws HeclException {

	System.out.println("Hello world");
	return null;
    }
}
      </programlisting>

      <para>
	The command takes an interpreter and an array of <classname>Thing</classname>s as arguments,
	where the first <classname>Thing</classname> is the name of the command itself, and the
	others are the arguments to it.
      </para>

      <para>
	The "glue" that connects the name of your Hecl command with the Java code is also relatively
	simple:
      </para>

      <programlisting>
	interp.addCommand("hello", new HelloCmd());
      </programlisting>

      <para>
	The above code would be included somewhere in <filename>commandline/Hecl.java</filename>,
	<filename>midp20/Hecl.java</filename> or elsewhere, depending on what platform you're
	working on; or <filename>core/org/hecl/Interp.java</filename> if you want to include it as
	part of the Hecl core.
      </para>

      <para>
	Easy, no?  There are a few other useful methods that you
	should be aware of, to share variables between Hecl and Java,
	and to return results from your Hecl commands:
      </para>

      <itemizedlist>
	<listitem>
	  <methodsynopsis>
	    <methodname>interp.setVar</methodname>
	    <methodparam>
	      <type>Thing</type>
	      <parameter>varname</parameter>
	    </methodparam>
	    <methodparam>
	      <type>Thing</type>
	      <parameter>value</parameter>
	    </methodparam>
	  </methodsynopsis>
	  <para>
	    This sets the value of <parameter>varname</parameter> to
	    some value.
	  </para>
	</listitem>

	<listitem>
	  <methodsynopsis>
	    <type>Thing</type>
	    <methodname>interp.getVar</methodname>
	    <methodparam>
	      <type>Thing</type>
	      <parameter>varname</parameter>
	    </methodparam>
	  </methodsynopsis>

	  <methodsynopsis>
	    <type>Thing</type>
	    <methodname>interp.getVar</methodname>
	    <methodparam>
	      <type>String</type>
	      <parameter>varname</parameter>
	    </methodparam>
	  </methodsynopsis>
	  <para>
	    These methods take a variable name, either in string form
	    or as a <classname>Thing</classname>, and return the
	    <classname>Thing</classname> associated with that
	    variable.
	  </para>
	</listitem>

	<listitem>
	  <para><varname>interp.result</varname> is used to set the
	    result of a command.  This oft-used variable is accessed
	    directly for simplicity, speed and smaller code size.
	  </para>
	</listitem>

	<listitem>
	  <methodsynopsis>
	    <type>int</type>
	    <methodname>IntThing.get</methodname>
	    <methodparam>
	      <type>Thing</type>
	      <parameter>thing</parameter>
	    </methodparam>
	  </methodsynopsis>
	  <para>Get an int from a Thing.</para>
	</listitem>

	<listitem>
	  <methodsynopsis>
	    <type>String</type>
	    <methodname>StringThing.get</methodname>
	    <methodparam>
	      <type>Thing</type>
	      <parameter>thing</parameter>
	    </methodparam>
	  </methodsynopsis>
	  <para>Get a String from a Thing.</para>
	</listitem>

	<listitem>
	  <methodsynopsis>
	    <type>Thing</type>
	    <methodname>IntThing.create</methodname>
	    <methodparam>
	      <type>int</type>
	      <parameter>i</parameter>
	    </methodparam>
	  </methodsynopsis>
	  <para>Creates a new thing from an int.</para>
	</listitem>

      </itemizedlist>

      <para>There are similar methods for strings, floats (where applicable), hashes and lists.</para>

    </section>

    <section xml:id="building_hecl">
      <title>Building Hecl: Ant Targets</title>

      <para>
	Since Hecl can be built for many different platforms, with many different capabilities, it
	requires a fairly complex build system, based on <link xl:href="http://ant.apache.org/">Ant</link>, <link xl:href="http://antenna.sourceforge.net/">Antenna</link>, and for Java ME, <link xl:href="http://proguard.sourceforge.net/">Proguard.</link>.  However, it's not necessary to
	understand the intricacies of this system unless you're doing more advanced hacking: in that
	case, you should ask on the mailing list if you need help.
      </para>

      <para>The most important build targets are the following:</para>

      <simplelist>
	<member><command>ant build</command>: Build everything.  This is a time-consuming process,
	but is the best way to make sure you have built everything with the latest code.
	</member>

	<member><command>ant packageCommandline</command>: Builds the
	<filename>jars/j2se/Hecl.jar</filename> file for the j2se/command line version of Hecl.
	</member>

	<member>
	  <command>ant -propertyfile ./cldc11midp20.properties midlet</command>: Builds the MIDP 2.0
	  version of Hecl.
	</member>

	<member>
	  <command>ant -propertyfile ./cldc10midp10.properties midlet</command>: Builds the MIDP 1.0
	  version of Hecl.
	</member>

	<member>
	  <command>ant installAndroidPackage</command>: Builds the Android version of Hecl and
	  installs it on the Android emulator, which must be running for the final step to work.
	</member>

	<member>
	  <command>ant docs</command>: Creates both the DocBook documentation and runs Javadoc.
	</member>

      </simplelist>

    </section>


    <section xml:id="hecl_javadocs">
      <title>JavaDocs</title>

      <para>
	For the complete Hecl javadoc documentation, see the <link xl:href="jdocs">Hecl Javadocs</link>.  And, of course, look at
	  the Hecl source code to see how it's done!
      </para>

    </section>

  </section>


  <section xml:id="j2me">
    <title>Hecl and Java ME</title>

    <para>
      Hecl is designed to be small enough to run on mobile devices
      such as cell phones.  This means that for the Hecl core, has
      been necessary to limit ourselves to Java API's that work with
      J2ME.
    </para>


    <section xml:id="javame_tutorial">
      <title>Hecl Java ME Tutorial</title>

    <note>
      <para>
	This is a tutorial showing you how to use Hecl to write applications for Java ME.  If you
	want a simple introduction to the Hecl language, you can find that here: <link
	linkend="tutorial">tutorial</link>.
      </para>
    </note>

      <para>
	This tutorial first appeared here:
	<link xl:href="http://www.freesoftwaremagazine.com/articles/creating_a_simple_application_with_hecl">
	  Create a simple application with Hecl - Introducing Hecl, a mobile phone scripting
	  language </link>.  It is a tutorial style introduction writing Hecl code for mobile
	  phones, by David Welton.
      </para>

      <para>
	The aim of this tutorial is to help you create cell phone applications, so let's get started
	right away. You'll need a few things first:
      </para>

      <itemizedlist>
	<listitem>
	  <para>
	    Sun's Java.  With Ubuntu, you can get this like so:
	  </para>
	  <screen>apt-get install openjdk-6-jdk</screen>
	</listitem>

	<listitem>
	  <para>
	    <link xl:href="http://java.sun.com/products/sjwtoolkit/index.jsp">Sun's
	    WTK toolkit</link>. While you don't need the tools to
	    compile Hecl (unless you want to hack on it!), you do want
	    the emulator, so that you don't have to load your app onto
	    your phone each time you want to test it. It's not open
	    source software (yet?), but it does run on Linux, Mac and
	    Windows, and of course it is free.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    Hecl itself. You can get the latest code here: <link
	    xl:href="http://www.hecl.org/downloads/hecl-latest.tgz">http://www.hecl.org/downloads/hecl-latest.tgz</link>.
	    <note>
	      <para>
		Hecl is always improving, so you should also consider checking out Hecl directly
		from git: <userinput>git clone git://github.com/davidw/hecl.git</userinput>
	      </para>
	    </note>
	  </para>
	</listitem>
      </itemizedlist>

      <para>
	Sun's WTK requires installation - you can put it somewhere like <filename>/opt</filename>,
	so it won't get mixed up with the rest of your system. The installation process is very
	simple - just say yes to a few questions, and you're done. Hecl doesn't require
	installation: everything you need is already there in the distribution.
      </para>

      <para>
	To see if everything's working, you can try launching the emulator with the sample
	application: <userinput>/opt/WTK2.5.2/bin/emulator -classpath
	jars/cldc1.1-midp2.0/Hecl.jar Hecl</userinput>
      </para>

      <note>
	<para>
	  With version 3 of the Sun WTK (which as of 2010-01 only runs
	  on Windows and Mac), the command line you need is as
	  follows:

	  <userinput>
	    /opt/WTK2.5.2/bin/emulator -Xjam:install jars/cldc1.1-midp2.0/Hecl.jad
	  </userinput>
	</para>
      </note>

      <para>That should bring up something like this:</para>

      <screenshot>
	<mediaobject>
	  <imageobject>
	    <imagedata fileref="demo_screenshot.png">
	    </imagedata>
	  </imageobject>
	  <caption><para>Figure 1: Hecl demo screen shot</para></caption>
	</mediaobject>
      </screenshot>

      <para>
	This is Hecl's built in demo - its source code is located in
	<filename>midp20/script.hcl</filename>, but before I get too far ahead of myself, let's go
	back and create the classic "Hello World" application, just to get started and see how to
	work with Hecl.
      </para>

      <note>
	<para>
	  Hecl actually comes in several flavors, with slightly different GUI commands - MIDP1.0
	  (older phones), which has fewer commands and doesn't do as much, and MIDP2.0, for newer
	  phones, which has a lot more features. This tutorial utilizes the MIDP2.0 commands,
	  because that's what current phones are based on. The concepts described are very similar
	  for the MIDP1.0 commands, but the commands are slightly different. Please contact us if
	  you are interested in a MIDP1.0 version of this tutorial.
	</para>
      </note>

      <para>
	To write your first Hecl program, open a text editor, and type the following program into a
	file - I'll call it <filename>hello.hcl</filename>:
      </para>

<programlisting>
proc HelloEvents {cmd form} {
    [lcdui.alert -text "Hellllllllooooo, world!" -timeout forever] setcurrent
}

set form [lcdui.form -title "Hello world" -commandaction HelloEvents]
set cmd [lcdui.command -label "Hello" -longlabel "Hello Command" -type screen]

$form setcurrent
$form addcommand $cmd

$form append [lcdui.stringitem -label "Hello" -text "World"]
</programlisting>

      <para>
	Not bad - 8 lines of code, and most of it's pretty clear just from looking at it. I'll go
	through it line by line, so you understand exactly what's happening.
      </para>

      <orderedlist>
	<listitem>
	  <para>
	    The first bit of code, that starts with <code>proc HelloEvents</code>, defines a
	    "procedure": in other words a function called <command>HelloEvents</command>. When this
	    function is called, it creates an "alert" - think of it as a pop up message telling you
	    something important. <option>-timeout forever</option> tells the message to stay on the
	    screen until the user dismisses it.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    The second command defines a form, with the command <command>lcdui.form</command>, with
	    the title of "Hello World", and connected to the <command>HelloEvents</command>
	    proc. What this connection means is that when any commands associated with the form are
	    activated by the user, this procedure is called to handle them. The code <code>set
	    form</code> stores the form object in the variable <varname>form</varname>, so that it
	    can be referenced later.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    The following line creates a command that can be activated by the user. It has the label
	    "Hello", and is stored in the variable <varname>cmd</varname>. I use the
	    <constant>screen</constant> type for the command, which is used for user defined
	    commands. There are some other predefined types such as <constant>exit</constant> and
	    <constant>back</constant>.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    <code>$form setcurrent</code> references the previously created form, and tells Hecl to
	    display it on the screen.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    The <command>addcommand</command> subcommand (you could also think of it as a "method",
	    like in an object oriented language) attaches the command I created above to the
	    form. This makes the command visible in the form.
	  </para>
	</listitem>


	<listitem>
	  <para>
	    Finally, I display a string on the form with the <command>lcdui.stringitem</command>
	    command. On most phones, the <option>-label</option> text is displayed in bold, and the
	    <option>-text</option> text is displayed next to it.
	  </para>
	</listitem>

      </orderedlist>

      <para>
	That's it! Now, to transform the code into a cell phone application, run a command:
      </para>

<programlisting>
java -jar jars/JarHack.jar -hecljar jars/cldc1.1-midp2.0/Hecl.jar \
    -destdir ~/ -name Hello -script hello.hcl
</programlisting>

      <para>
	This is all it takes - this command takes the existing <filename>Hecl.jar</filename> file,
	and replaces the Hecl script within with our newly created <filename>hello.hcl</filename>
	script, and creates the resulting <filename>Hello.jar</filename> in your home directory
	(referenced as <filename>~/</filename> in the command above).
      </para>

      <para>
	Now, we can run the code in the emulator to see the application:
      </para>

<programlisting>
/opt/WTK2.5.2/bin/emulator -cp ~/Hello.jar Hecl
</programlisting>

      <screenshot>
	<mediaobject>
	  <imageobject>
	    <imagedata fileref="hello_screenshot1.png">
	    </imagedata>
	  </imageobject>
	  <caption><para>Figure 2: Hecl Hello World screenshot</para></caption>
	</mediaobject>
      </screenshot>

      <para>
	Highlighted, from the top, are the form's <option>-title</option>, the
	<command>stringitem</command>, and in the lower right corner, the command labeled Hello.
      </para>

      <para>
	If you press the "hello" button, the code in <command>HelloEvents</command> is executed, and
	an "alert" is popped up onto the screen, and stays there until you hit the "Done"
	button.
      </para>

      <para>
	While creating an application is very easy, unfortunately, installing it on a phone is not;
	there isn't much that Hecl can do to ease that process, which is different for each
	phone. On Linux, for my Nokia telephone, I use the gammu program to transfer programs to my
	phone, like so:
      </para>

      <programlisting>gammu nothing --nokiaaddfile Application Hecl</programlisting>

      <para>
	Another method that may work better across different phones is to use the phone's browser to
	download and install the application, by placing the <filename>.jar</filename> and
	<filename>.jad</filename> files on a publicly accessible web server, and accessing the
	<filename>.jad</filename> file.
	<note>
	  <para>Note that this will likely cost money in connection charges!</para>
	</note>
      </para>

      <para>
	So far so good. Next, I'll create a small application that you can interact with to do
	something useful. It's a simplified version of the shopping list that can be found <link xl:href="http://shoplist.dedasys.com">here</link>. The theory of operation behind this
	application is simple: typing a shopping list into a mobile phone is pretty painful - it's
	much better to do the data entry via a web page, and then fetch the list with the mobile
	phone application.
      </para>

      <para>
	For this tutorial, I've created a simple list on the ShopList web site, with the PIN number
	<constant>346764</constant>, which can be viewed <link
	xl:href="http://shoplist.dedasys.com/list/show/346764">here</link>. Feel free to create your
	own shopping lists - the site costs nothing to use. The cell phone application works like
	so: by entering the PIN, it downloads the list of items and displays them on the phone
	screen as a series of checkboxes. Have a look at the code to do this:
      </para>

<programlisting>
# Process events associated with the shopping list screen.
proc ShopListEvents {exitcmd backcmd cmd shoplist} {
    if { eq $cmd $exitcmd } {
	midlet.exit
    } elseif { eq $cmd $backcmd } {
	global shopform
	$shopform setcurrent
    }
}

# Create a new shopping list screen and fetch .
proc MakeList {exitcmd backcmd pin} {
    set url "http://shoplist.dedasys.com/list/fetch/${pin}"
    # Fetch the data, and retrieve the data field from the results hash.
    set data [hget [http.geturl $url] data]
    if { eq $data "PIN NOT FOUND" } {
	[lcdui.alert -type warning \
	     -title "Pin Not Found" \
	     -timeout forever\
	     -text "The PIN $pin was not found on shoplist.dedasys.com"] setcurrent
	return
    }
    set shoplist [lcdui.list -title "Shopping List" \
		      -type multiple]
    foreach e [split $data \n] {
	$shoplist append $e
    }
    $shoplist addcommand $exitcmd
    $shoplist addcommand $backcmd
    $shoplist setcurrent
    $shoplist configure -commandaction \
	[list ShopListEvents $exitcmd $backcmd]
}

# Process events associated with the main form.
proc ShopFormEvents {backcmd exitcmd pinfield
		     fetchcmd cmd shopform} {
    if { eq $cmd $exitcmd } {
	midlet.exit
    } elseif { eq $fetchcmd $cmd } {
	MakeList $exitcmd $backcmd \
	    [$pinfield cget -text]
    }
}

# The action starts here...

# Create a generic back command.
set backcmd [lcdui.command \
		 -label Back \
		 -longlabel Back -type back -priority 1]
# Create an exit command.
set exitcmd [lcdui.command \
		 -label Exit \
		 -longlabel Exit -type exit -priority 2]

# Create the form.
set shopform [lcdui.form -title "Shopping List"]
set pinfield [lcdui.textfield \
		  -label "shoplist.dedasys.com PIN:" \
	          -type numeric]
set fetchcmd [lcdui.command -label "Fetch" \
		  -longlabel "Fetch Shopping List" \
		  -type screen -priority 1]

$shopform append $pinfield
$shopform addcommand $exitcmd
$shopform addcommand $fetchcmd
$shopform setcurrent

$shopform configure -commandaction \
    [list ShopFormEvents $backcmd $exitcmd $pinfield $fetchcmd]
</programlisting>

      <para>
	This is certainly more complex than the first example, but the general pattern is the same -
	screen widgets and items are created, displayed, and procs are called to deal with
	commands.
      </para>

      <para>
	As I mentioned previously, commands with specific, predefined tasks have their own types, as
	I can see with the <command>back</command> and <command>exit</command> commands, which are respectively
	of types "back" and "exit".
      </para>

      <para>
	After the two commands are defined, I create a form and add a textfield to it. By specifying
	<option>-type numeric</option> for the textfield, I indicate that it is only to accept
	numbers - no letters or symbols.
      </para>

      <para>
	After creating the Fetch command, I append the textfield to the form (or else it wouldn't be
	visible), add the two commands to the form, and then, with <command>setcurrent</command>,
	make the form visible. The last line of code configures the form to utilize the
	<command>ShopFormEvents</command> proc to handle events. The list argument warrants further
	explanation:
      </para>

      <para>
	Hecl, like many programming languages, has a <command>global</command> command that could be
	used in the various procs that utilize the <command>back</command> and
	<command>exit</command> commands - you could simply say <code>global backcmd</code>, and
	then the <varname>$backcmd</varname> variable would be available in that procedure. However,
	using global variables all over the place gets kind of messy, so what I want to do is pass
	in everything that the proc might need, and I do so by creating a list: <code>ShopFormEvents
	$backcmd $exitcmd $pinfield $fetchcmd</code>. You can see that these corresponds to the
	arguments that the proc takes: <code>proc ShopFormEvents {backcmd exitcmd pinfield fetchcmd
	cmd shopform}</code>, except for the last two, which Hecl
	<emphasis>automatically</emphasis> passes in. <varname>cmd</varname> is the command that was
	actually called, and <varname>shopform</varname> is of course the form that the proc was
	called with. By comparing <varname>$cmd</varname> with the various commands that are
	available, it's possible to determine which command called the proc, and act accordingly.
      </para>


      <para>Now, let's build it and run it:</para>

<programlisting>
java -jar jars/JarHack.jar -hecljar jars/cldc1.1-midp2.0/Hecl.jar \
    -destdir ~/ -name ShopList -script shoplist.hcl
/opt/WTK2.5.2/bin/emulator -classpath ShopList.jar Hecl
</programlisting>

      <screenshot>
	<mediaobject>
	  <imageobject>
	    <imagedata fileref="shoplist1.png">
	    </imagedata>
	  </imageobject>
	  <caption>
	    <para>Figure 3: Initial shoplist form</para>
	  </caption>
	</mediaobject>

      </screenshot>

      <para>
	At this point, you enter the PIN number (<constant>346764</constant>), and press the Fetch
	button. This command executes the code in <command>MakeList</command>. The first thing it
	does is attempt to fetch the data from the shoplist site, using the
	<command>http.geturl</command> command. Since this command returns a hash table, in order to
	get at the data returned, I use the <command>hget</command> command to access the "data"
	element. If the PIN was not available on the server, an error message is returned, and the
	user is returned to the first screen. Otherwise, a list of checkboxes is created with
	<command>lcdui.list</command>, by specifying "multiple" as the type. Since the shopping list
	is sent "over the wire" (so to speak...) as a list of lines, all I have to do to add it to
	the display is split it by lines with the <command>split</command> command, and then iterate
	over that list with <command>foreach</command>. The result looks like that displayed figure
	4.
      </para>

      <screenshot>
	<mediaobject>
	  <imageobject>
	    <imagedata fileref="shoplist2.png">
	    </imagedata>
	  </imageobject>
	  <caption><para>Figure 4: Shopping List</para></caption>
	</mediaobject>
      </screenshot>

      <para>
	And there you have it, a network-based shopping list in less than 100 lines of code. Of
	course, there is room for improvement. For instance, in the production version of this
	shopping list application, RecordStore (in Hecl, the <command>rms.*</command> commands make
	this functionality available) is utilized to save the list and its state between invocations
	of the program, so that you can leave the application, run it again, and find the list as
	you left it. Support for multiple lists might also be handy.
      </para>

      <para>
	Of course, this tutorial barely scratches the surface. Hecl has a number of other GUI
	commands, and is a complete programming language that can do some interesting and dynamic
	things. If you're curious, the best way to learn more is to keep reading the documentation,
	and sign up for the <link xl:href="http://groups.google.com/group/hecl">Hecl Google
	Group</link>, which can be accessed either as a web forum or as a mailing list.
      </para>

    </section>

    <section xml:id="javame_quick_start">
      <title>Quick start to developing Java ME apps</title>

      <para>
	Creating new Hecl applications is quick and easy:
      </para>

      <procedure>
	<step>
	  <para>
	    Create a Hecl script.  For starters, you could use the <filename>hello.hcl</filename>
	    script from the tutorial.
	  </para>
	</step>

	<step>
	  <para>
	    Use <command>JarHack</command> to create a new jar and accompanying
	    jad file:
	  </para>
	  <programlisting>java -jar jars/JarHack.jar -hecljar jars/cldc1.1-midp2.0/Hecl.jar -destdir /tmp -name Hello -script hello.hcl</programlisting>
	  <para>
	    This creates <filename>Hello.jar</filename> and <filename>Hello.jad</filename> in the
	    <filename>/tmp</filename> directory, using the <filename>hello.hcl</filename> script.
	    It utilizes the MIDP 2.0 version of Hecl in <filename>jars/cldc1.1-midp2.0/Hecl.jar</filename>
	  </para>
	</step>

	<step>
	  <para>To run this code in the emulator:</para>
	  <programlisting>/opt/WTK2.5.2/bin/emulator -classpath /tmp/Hello.jar Hecl</programlisting>
	</step>

	<step performance="optional">
	  <para>
	    Once you've iterated through a few versions of the script, and are satisfied, you're
	    ready to move it to your phone.  Unfortunately, we can't do that for you, as there is no
	    standard method - each phone manufacturer provides their own way.  On Linux, I use the
	    following command:
	  </para>
	  <programlisting>gammu nothing --nokiaaddfile Application Hecl</programlisting>

	  <para>
	    Another way to accomplish this is to put the jar and jad files on a web site and
	    download them with your phone's browser.
	  </para>
	</step>

      </procedure>
    </section>


    <section xml:id="midp10_commands">
      <title>Hecl J2ME MIDP1.0 Commands</title>

      <note>
	<para>
	  Hecl has different GUI commands for the MIDP1.0 (older
	  phones) and MIDP2.0 (newer).  We are in the process of
	  documenting the MIDP2.0 commands.
	</para>
      </note>

      <para>
	Commands available in the J2ME MIDP1.0 version of Hecl to
	interact with the phone.  Look in the
	<filename>midp10/examples</filename> directory for examples of
	these commands and widgets in use.
      </para>

      <refentry xml:id="midp10_alert">
	<refnamediv>
	  <refname>alert</refname>
	  <refpurpose>Creates an alert</refpurpose>
	</refnamediv>
	<refsynopsisdiv>
	  <cmdsynopsis>
	    <command>alert</command>
	    <arg choice="opt">label <replaceable>title</replaceable></arg>
	    <arg choice="opt">text <replaceable>text</replaceable></arg>
	    <arg choice="opt">type
	      <group>
		<arg choice="req">alarm</arg>
		<arg choice="req">confirmation</arg>
		<arg choice="req">error</arg>
		<arg choice="req">error</arg>
		<arg choice="req">info</arg>
		<arg choice="req">warning</arg>
	      </group>
	    </arg>
	  </cmdsynopsis>
	</refsynopsisdiv>
	<refsect1>
	  <title>Description</title>
	  <para>
	    The lcdui <classname>Alert</classname> class.  You must
	    call <command>setcurrent</command> to actually display the
	    alert.
	  </para>
	</refsect1>
      </refentry>

      <refentry xml:id="midp10_choicegroup">
	<refnamediv>
	  <refname>choicegroup</refname>
	  <refpurpose>Displays a choicegroup in the current form</refpurpose>
	</refnamediv>
	<refsynopsisdiv>
	  <cmdsynopsis>
	    <command>choicegroup</command>
	    <arg choice="opt">label <replaceable>label</replaceable></arg>
	    <arg choice="opt">type
	      <group>
		<arg choice="req">exclusive</arg>
		<arg choice="req">implicit</arg>
		<arg choice="req">multiple</arg>
	      </group>
	    </arg>
	    <arg choice="opt">list <replaceable>list</replaceable></arg>
	  </cmdsynopsis>
	</refsynopsisdiv>
	<refsect1>
	  <title>Description</title>
	  <para>
	    The lcdui <classname>ChoiceGroup</classname> class.
	  </para>
	</refsect1>
      </refentry>

      <refentry xml:id="midp10_cmd">
	<refnamediv>
	  <refname>cmd</refname>
	  <refpurpose>Adds a command to a form/listbox/textbox</refpurpose>
	</refnamediv>
	<refsynopsisdiv>
	  <cmdsynopsis>
	    <command>cmd</command>
	    <arg choice="opt">label <replaceable>label</replaceable></arg>
	    <arg choice="opt">type
	      <group>
		<arg choice="req">back</arg>
		<arg choice="req">cancel</arg>
		<arg choice="req">exit</arg>
		<arg choice="req">help</arg>
		<arg choice="req">item</arg>
		<arg choice="req">ok</arg>
		<arg choice="req">screen</arg>
		<arg choice="req">stop</arg>
	      </group>
	    </arg>
	    <arg choice="opt">code <replaceable>code</replaceable></arg>
	  </cmdsynopsis>
	</refsynopsisdiv>
	<refsect1>
	  <title>Description</title>
	  <para>
	    This is used to create and associate commands with a
	    screen widget (form, listbox, textbox). The lcdui
	    <classname>Command</classname> class.
	  </para>
	</refsect1>
      </refentry>

      <refentry xml:id="midp10_datefield">
	<refnamediv>
	  <refname>datefield</refname>
	  <refpurpose>Displays an datefield in the current form</refpurpose>
	</refnamediv>
	<refsynopsisdiv>
	  <cmdsynopsis>
	    <command>datefield</command>
	    <arg choice="opt">label</arg>
	    <arg choice="opt">typ
	      <group>
		<arg choice="req">date_time</arg>
		<arg choice="req">date</arg>
		<arg choice="req">time</arg>
	      </group>
	    </arg>
	  </cmdsynopsis>
	</refsynopsisdiv>
	<refsect1>
	  <title>Description</title>
	  <para>
	    The lcdui <classname>DateField</classname> class.
	  </para>
	</refsect1>
      </refentry>

      <refentry xml:id="midp10_j2me_exit">
	<refnamediv>
	  <refname>exit</refname>
	  <refpurpose>Exits the application</refpurpose>
	</refnamediv>
	<refsynopsisdiv>
	  <cmdsynopsis>
	    <command>exit</command>
	  </cmdsynopsis>
	</refsynopsisdiv>
	<refsect1>
	  <title>Description</title>
	  <para>
	    Exits the application.
	  </para>
	</refsect1>
      </refentry>

      <refentry xml:id="midp10_form">
	<refnamediv>
	  <refname>form</refname>
	  <refpurpose>Creates a form</refpurpose>
	</refnamediv>
	<refsynopsisdiv>
	  <cmdsynopsis>
	    <command>form</command>
	    <arg choice="opt">label <replaceable>title</replaceable></arg>
	    <arg choice="opt">code <replaceable>code</replaceable></arg>
	  </cmdsynopsis>
	</refsynopsisdiv>
	<refsect1>
	  <title>Description</title>
	  <para>
	    The lcdui <classname>Form</classname> class.  Note that in
	    order to actually display the newly created form, you must
	    call the <command>setcurrent</command> command with a
	    reference to the form as an argument.
	  </para>
	</refsect1>
      </refentry>

      <refentry xml:id="midp10_gauge">
	<refnamediv>
	  <refname>gauge</refname>
	  <refpurpose>Displays an gauge in the current form</refpurpose>
	</refnamediv>
	<refsynopsisdiv>
	  <cmdsynopsis>
	    <command>gauge</command>
	    <arg choice="opt">label <replaceable>label</replaceable></arg>
	    <arg choice="opt">maxval
	    <replaceable>maximum_value</replaceable></arg>
	    <arg choice="opt">val
	    <replaceable>initial_value</replaceable></arg>
	    <arg choice="opt">interactive
	      <group>
		<arg choice="req">1</arg>
		<arg choice="req">0</arg>
	      </group>
	    </arg>
	  </cmdsynopsis>
	</refsynopsisdiv>
	<refsect1>
	  <title>Description</title>
	  <para>
	    The lcdui <classname>Gauge</classname> class.
	  </para>
	</refsect1>
      </refentry>

      <refentry xml:id="midp10_getindex">
	<refnamediv>
	  <refname>getindex</refname>
	  <refpurpose>Fetches a reference to the N'th element in a
	  given form/listbox</refpurpose>
	</refnamediv>
	<refsynopsisdiv>
	  <cmdsynopsis>
	    <command>getindex</command>
	    <arg choice="req"><replaceable>widget</replaceable></arg>
	    <arg choice="req"><replaceable>index</replaceable></arg>
	  </cmdsynopsis>
	</refsynopsisdiv>
	<refsect1>
	  <title>Description</title>
	  <para>
	    Fetches the N'th element in a form.
	  </para>
	</refsect1>
      </refentry>

      <refentry xml:id="midp10_getprop">
	<refnamediv>
	  <refname>getprop</refname>
	  <refpurpose>Fetches the value of a given property from a widget</refpurpose>
	</refnamediv>
	<refsynopsisdiv>
	  <cmdsynopsis>
	    <command>getprop</command>
	    <arg choice="req"><replaceable>widget</replaceable></arg>
	    <arg choice="req"><replaceable>property</replaceable></arg>
	  </cmdsynopsis>
	</refsynopsisdiv>
	<refsect1>
	  <title>Description</title>
	  <para>
	    Fetches the value of a given property.  For example:
	  </para>
	  <programlisting>
	    set tf [textfield label "Insert text:"]
	    ...
	    set inserted_text [getprop $tf text]
	  </programlisting>
	  <para>
	    In this example, <command>getprop</command> fetches the
	    text that has been inserted in the textfield.
	    <option><replaceable>property</replaceable></option> must
	    be a valid property for the given widget.
	  </para>
	</refsect1>
      </refentry>

      <refentry xml:id="midp10_listbox">
	<refnamediv>
	  <refname>listbox</refname>
	  <refpurpose>Creates a listbox</refpurpose>
	</refnamediv>
	<refsynopsisdiv>
	  <cmdsynopsis>
	    <command>listbox</command>
	    <arg choice="opt">label <replaceable>title</replaceable></arg>
	    <arg choice="opt">type
	      <group>
		<arg choice="req">exclusive</arg>
		<arg choice="req">implicit</arg>
		<arg choice="req">multiple</arg>
	      </group>
	    </arg>
	    <arg choice="opt">code
	    <replaceable>code</replaceable></arg>
	    <arg choice="opt">callback <replaceable>code</replaceable></arg>
	  </cmdsynopsis>
	</refsynopsisdiv>
	<refsect1>
	  <title>Description</title>
	  <para>
	    Similar to the lcdui <classname>ListBox</classname> class,
	    but implemented as a class that extends
	    <classname>Form</classname>, in order to enable the use of
	    callbacks.  Like forms and textboxes, it is necessary to
	    use the <command>setcurrent</command> command to actually
	    display a listbox.
	  </para>
	</refsect1>
      </refentry>

      <refentry xml:id="midp10_noscreen">
	<refnamediv>
	  <refname>noscreen</refname>
	  <refpurpose>Runs without a current screen widget</refpurpose>
	</refnamediv>
	<refsynopsisdiv>
	  <cmdsynopsis>
	    <command>noscreen</command>
	    <arg choice="req">code</arg>
	  </cmdsynopsis>
	</refsynopsisdiv>
	<refsect1>
	  <title>Description</title>
	  <para>
	    Normally, there is almost always a default screen widget
	    present, so that when items are created, they are
	    automatically added to the screen widget that is in
	    effect.  The <command>noscreen</command> command executes
	    the code passed to it without a default screen widget.
	  </para>
	</refsect1>
      </refentry>

      <refentry xml:id="midp10_screenappend">
	<refnamediv>
	  <refname>screenappend</refname>
	  <refpurpose>Appends an item to a form or listbox</refpurpose>
	</refnamediv>
	<refsynopsisdiv>
	  <cmdsynopsis>
	    <command>screenappend</command>
	    <arg
	    choice="req"><replaceable>screen_widget</replaceable></arg>
	    <arg choice="req"><replaceable>widget</replaceable></arg>
	  </cmdsynopsis>
	</refsynopsisdiv>
	<refsect1>
	  <title>Description</title>
	  <para>
	    Appends an
	    <option><replaceable>widget</replaceable></option> to the
	    form or listbox
	    <option><replaceable>screen_widget</replaceable></option>.
	  </para>
	</refsect1>
      </refentry>

      <refentry xml:id="midp10_setcurrent">
	<refnamediv>
	  <refname>setcurrent</refname>
	  <refpurpose>Displays an alert/form/listbox/textbox</refpurpose>
	</refnamediv>
	<refsynopsisdiv>
	  <cmdsynopsis>
	    <command>setcurrent</command>
	    <arg choice="req">screen_widget</arg>
	  </cmdsynopsis>
	</refsynopsisdiv>
	<refsect1>
	  <title>Description</title>
	  <para>
	    Screen widgets (alerts, forms, listboxes and textboxes),
	    are not displayed when created.
	    <command>setcurrent</command> displays them.  For example:
	  </para>
	  <programlisting>
	    set f [form label "New Form"]
	    setcurrent $f
	  </programlisting>
	</refsect1>
      </refentry>

      <refentry xml:id="midp10_setindex">
	<refnamediv>
	  <refname>setindex</refname>

	  <refpurpose>
	    Sets the
	    <option><replaceable>index</replaceable></option>th
	    element in a form/listbox to specified item</refpurpose>
	</refnamediv>
	<refsynopsisdiv>
	  <cmdsynopsis>
	    <command>setindex</command>
	    <arg choice="req"><replaceable>widget</replaceable></arg>
	    <arg choice="req"><replaceable>index</replaceable></arg>
	    <arg choice="req"><replaceable>newitem</replaceable></arg>
	  </cmdsynopsis>
	</refsynopsisdiv>
	<refsect1>
	  <title>Description</title>
	  <para>
	    Sets the
	    <option><replaceable>index</replaceable></option>'th item
	    of a form/listbox to item
	    <option><replaceable>newitem</replaceable></option>.
	  </para>
	</refsect1>
      </refentry>

      <refentry xml:id="midp10_setprop">
	<refnamediv>
	  <refname>setprop</refname>
	  <refpurpose>Sets a given property of a widget</refpurpose>
	</refnamediv>
	<refsynopsisdiv>
	  <cmdsynopsis>
	    <command>setprop</command>
	    <arg choice="req"><replaceable>widget</replaceable></arg>
	    <arg
	    choice="req"><replaceable>property</replaceable></arg>
	    <arg choice="req"><replaceable>new_value</replaceable></arg>
	  </cmdsynopsis>
	</refsynopsisdiv>
	<refsect1>
	  <title>Description</title>
	  <para>
	    Sets the value of a given widget's property.
	  </para>
	</refsect1>
      </refentry>

      <refentry xml:id="midp10_string">
	<refnamediv>
	  <refname>string</refname>
	  <refpurpose>Adds a string to the current form.</refpurpose>
	</refnamediv>
	<refsynopsisdiv>
	  <cmdsynopsis>
	    <command>string</command>
	    <arg choice="req"><replaceable>string</replaceable></arg>
	  </cmdsynopsis>
	</refsynopsisdiv>
	<refsect1>
	  <title>Description</title>
	  <para>
	    Appends the specified
	    <option><replaceable>string</replaceable></option> to the
	    current form.
	  </para>
	</refsect1>
      </refentry>

      <refentry xml:id="midp10_stringitem">
	<refnamediv>
	  <refname>stringitem</refname>
	  <refpurpose>Displays a stringitem in the current form</refpurpose>
	</refnamediv>
	<refsynopsisdiv>
	  <cmdsynopsis>
	    <command>stringitem</command>
	    <arg choice="opt">label <replaceable>label</replaceable></arg>
	    <arg choice="opt">text <replaceable>text</replaceable></arg>
	  </cmdsynopsis>
	</refsynopsisdiv>
	<refsect1>
	  <title>Description</title>
	  <para>
	    The lcdui <classname>StringItem</classname> class.
	  </para>
	</refsect1>
      </refentry>

      <refentry xml:id="midp10_textbox">
	<refnamediv>
	  <refname>textbox</refname>
	  <refpurpose>Creates a textbox</refpurpose>
	</refnamediv>
	<refsynopsisdiv>
	  <cmdsynopsis>
	    <command>textbox</command>
	    <arg choice="opt">label <replaceable>title</replaceable></arg>
	    <arg choice="opt">len <replaceable>length_in_characters</replaceable></arg>
	    <arg choice="opt">type
	      <group>
		<arg choice="req">any</arg>
		<arg choice="req">emailaddr</arg>
		<arg choice="req">numeric</arg>
		<arg choice="req">phonenumber</arg>
		<arg choice="req">passwd</arg>
		<arg choice="req">url</arg>
	      </group>
	    </arg>
	    <arg choice="opt">text
	    <replaceable>text</replaceable></arg>
	    <arg choice="opt">code <replaceable>code</replaceable></arg>
	  </cmdsynopsis>
	</refsynopsisdiv>
	<refsect1>
	  <title>Description</title>
	  <para>
	    The lcdui <classname>TextBox</classname> class.  To
	    display a textbox, you must use the
	    <command>setcurrent</command> command.
	  </para>
	</refsect1>
      </refentry>

      <refentry xml:id="midp10_textfield">
	<refnamediv>
	  <refname>textfield</refname>
	  <refpurpose>Displays a textfield in the current form</refpurpose>
	</refnamediv>
	<refsynopsisdiv>
	  <cmdsynopsis>
	    <command>textfield</command>
	    <arg choice="opt">label
	    <replaceable>label</replaceable></arg>
	    <arg choice="opt">len <replaceable>length_in_characters</replaceable></arg>
	    <arg choice="opt">type
	      <group>
		<arg choice="req">any</arg>
		<arg choice="req">emailaddr</arg>
		<arg choice="req">numeric</arg>
		<arg choice="req">phonenumber</arg>
		<arg choice="req">passwd</arg>
		<arg choice="req">url</arg>
	      </group>
	    </arg>
	    <arg choice="opt">text <replaceable>text</replaceable></arg>
	  </cmdsynopsis>
	</refsynopsisdiv>
	<refsect1>
	  <title>Description</title>
	  <para>
	    The lcdui <classname>TextField</classname> class.
	  </para>
	</refsect1>
      </refentry>

    </section>

    <section xml:id="midp20commands">
      <title>Hecl Java ME MIDP2.0 Commands</title>

      <para>
	The MIDP 2.0 commands in Hecl are more complete and more
	advanced than the 1.0 commands, and should be used if
	possible.  This is a fairly complete list of which devices are
	MIDP2.0 capable: <link xl:href="http://devices.j2mepolish.org/interactivedb/searchdevices.faces"
	/>
      </para>

      <para>
	To fully understand these commands, a perusal of the
	documentation here is likely a good idea: <link xl:href="http://java.sun.com/javame/reference/apis/jsr118/"></link>
	In particular, look at the lcdui package.
      </para>

      <para>
	This code was originally written and contributed to Hecl by
	Wolfgang Kechel.  Thanks!
      </para>

      <refentry xml:id="lcdui_alert">
	<refnamediv>
	  <refname>lcdui.alert</refname>
	  <refpurpose>Pops up an alert</refpurpose>
	</refnamediv>
	<refsynopsisdiv>
	  <cmdsynopsis>
	    <command>lcdui.alert</command>
	    <arg choice="opt">-title <replaceable>title</replaceable></arg>
	    <arg choice="opt">-ticker <replaceable>tickerwidget</replaceable></arg>
	    <arg choice="opt">-commandaction <replaceable>commandActionProc</replaceable></arg>

	    <arg choice="opt">-type
	      <group choice="req">
		<arg choice="req">info</arg>
		<arg choice="req">warning</arg>
		<arg choice="req">error</arg>
		<arg choice="req">alarm</arg>
		<arg choice="req">confirmation</arg>
	      </group>
	    </arg>
	    <arg choice="opt">-text
	    <replaceable>text</replaceable></arg>
	    <arg choice="opt">-timeout
	      <group choice="req">
		<arg choice="req"><replaceable>milliseconds</replaceable></arg>
		<arg choice="req">forever</arg>
	      </group>
	    </arg>
	    <arg choice="opt">-indicator
	      <group choice="req">
		<arg choice="req">1</arg>
		<arg choice="req">0</arg>
	      </group>
	    </arg>
	  </cmdsynopsis>

	  <cmdsynopsis>
	    <command><replaceable>$alertcmd</replaceable></command>
	    <arg choice="req">setcurrent</arg>
	    <arg choice="opt">cget
	      <replaceable>-optname</replaceable>
	    </arg>
	    <arg choice="opt">configure
	      <replaceable>-optname</replaceable>
	      <replaceable>optval</replaceable>
	    </arg>
	  </cmdsynopsis>
	</refsynopsisdiv>
	<refsect1>
	  <title>Description</title>
	  <para>
	    The <command>lcdui.alert</command> command creates an
	    alert to let the user know that something unusual has
	    happened, or to ask for confirmation.  The object returned
	    from <command>lcdui.alert</command> is itself a command,
	    that can be called with a subcommand
	    <option>setcurrent</option> to make the alert the
	    currently displayed item.  For an in-depth look at the
	    Java code that this command is based on, see: <link xl:href="http://java.sun.com/javame/reference/apis/jsr118/javax/microedition/lcdui/Alert.html">javax.microedition.lcdui.Alert</link>
	  </para>
	</refsect1>
	<refsect1>
	  <title>Example</title>
	  <programlisting>
[lcdui.alert -title "Reactor core meltdown" -text \
    "You went and pressed the red button, didn't you!" \
    -timeout forever] setcurrent
	  </programlisting>

	  <para>
	    Live example: <link xl:href="http://www.heclbuilder.com/scripts/show/141" />
	  </para>
	</refsect1>
      </refentry>

      <refentry xml:id="lcdui_canvas">
	<refnamediv>
	  <refname>lcdui.canvas</refname>
	  <refpurpose>Creates a canvas</refpurpose>
	</refnamediv>
	<refsynopsisdiv>
	  <cmdsynopsis>
	    <command>lcdui.canvas</command>
	    <arg choice="opt">-autoflush
	      <group choice="req">
		<arg choice="req">1</arg>
		<arg choice="req">0</arg>
	      </group>
	    </arg>

	    <arg choice="opt">-cmdbg
	      <replaceable>color</replaceable>
	    </arg>

	    <arg choice="opt">-cmdfg
	      <replaceable>color</replaceable>
	    </arg>

	    <arg choice="opt">-eventhandler
	      <replaceable>code</replaceable>
	    </arg>

	    <arg choice="opt">-fullscreen
	      <group choice="req">
		<arg choice="req">1</arg>
		<arg choice="req">0</arg>
	      </group>
	    </arg>

	    <arg choice="opt">-title <replaceable>title</replaceable></arg>

	    <arg choice="opt">-suppresskeys
	      <group choice="req">
		<arg choice="req">1</arg>
		<arg choice="req">0</arg>
	      </group>
	    </arg>
	  </cmdsynopsis>

	  <cmdsynopsis>
	    <command><replaceable>$canvascmd</replaceable></command>

	    <arg choice="opt">cget
	      <replaceable>-optname</replaceable>
	    </arg>
	    <arg choice="opt">configure
	      <replaceable>-optname</replaceable>
	      <replaceable>optval</replaceable>
	    </arg>

	    <arg choice="opt">flush
	      <arg choice="opt"><replaceable>x y width height</replaceable></arg>
	    </arg>
	    <arg choice="opt">graphics</arg>
	    <arg choice="opt">repaint</arg>
	    <arg choice="opt">servicerepaints</arg>
	  </cmdsynopsis>

	</refsynopsisdiv>
	<refsect1>
	  <title>Description</title>

	  <para>
	    The <command>lcdui.canvas</command> command creates a
	    canvas that can be used to draw arbitrary items, such as
	    rectangles, text, circles, and respond to keyboard events.
	    For an in-depth look at the Java code that this command is
	    based on, see: <link xl:href="http://java.sun.com/javame/reference/apis/jsr118/javax/microedition/lcdui/game/GameCanvas.html">javax.microedition.lcdui.game.GameCanvas</link>
	  </para>
	  <para>
	    The options describing the canvas are as follows:
	  </para>
	  <itemizedlist>
	    <listitem>
	      <para><option>-autoflush</option>: Takes a boolean
		argument (1 or 0) indicating FIXME</para></listitem>
	    <listitem>
	      <para>
		<option>-cmdbg</option>: Selects a background color for
		the command background.
	      </para>
	    </listitem>

	    <listitem>
	      <para>
	      <option>-cmdfg</option>: Selects a background color for
	      the command foreground.
	    </para>
	    </listitem>

	    <listitem>
	      <para>
		<option>-eventhandler</option>: The Hecl code to execute
		when an event is generated.
	      </para>
	    </listitem>

	    <listitem>
	      <para>
		<option>-fullscreen</option>: A boolean switch
		specifying whether to run in "full screen" mode.
		"Full screen" mode means that commands, which would
		normally be accessible via certain keys on the cell
		phone, are not accessible, and that those keys
		generate regular events instead of calling commands.
	      </para>
	    </listitem>

	    <listitem>
	      <para>
		<option>-suppresskeys</option>: A boolean switch
		specifying whether to suppress key events or not.
		Suppressing these events, if the application does not
		need to keep track of them, may improve performance
		some.
	      </para>
	    </listitem>
	  </itemizedlist>
	  <para>
	    The <command>lcdui.canvas</command> command returns an
	    object that is itself a command, and can be called with
	    several subcommands:
	  </para>
	  <itemizedlist>
	    <listitem>
	      <para>
		<command>flush</command>: With no argument, flushes
		(displays) the off-screen buffer to the visible
		display.  With arguments <option><replaceable>x y
		width height</replaceable></option>, flushes the
		specified section to the screen.
	      </para>
	    </listitem>
	    <listitem>
	      <para>
		<command>graphics</command>: Returns a graphics object
		that acts as a command to manipulate the Canvas'
		graphics buffer.
	      </para>
	    </listitem>
	    <listitem>
	      <para>
		<command>repaint</command>: Repaints the entire canvas.
	      </para>
	    </listitem>
	    <listitem>
	      <para>
		<command>servicerepaints</command>: Forces any repaints
		that haven't occured yet to be performed immediately.
	      </para>
	    </listitem>
	  </itemizedlist>
	</refsect1>
	<refsect1>
	  <title>Example</title>
	  <programlisting>
set canvas [lcdui.canvas -title "Test Canvas" -commandaction backToMainMenu \
    -eventhandler canvasEvents]
set graphics [$canvas graphics]
$graphics frect [list 10 10] [list 10 80]
$graphics frect [list 80 10] [list 10 80]
$graphics frect [list 10 50] [list 80 10]
$canvas setcurrent
	  </programlisting>
	  <para>
	    Live example: <link xl:href="http://www.heclbuilder.com/scripts/show/142" />
	  </para>
	</refsect1>
      </refentry>

      <refentry xml:id="lcdui_choicegroup">
	<refnamediv>
	  <refname>lcdui.choicegroup</refname>
	  <refpurpose>Creates a group of potential choices that can be
	  added to a form.</refpurpose>
	</refnamediv>
	<refsynopsisdiv>
	  <cmdsynopsis>
	    <command>lcdui.choicegroup</command>
	    <arg choice="opt">
	      -label
	      <replaceable>label</replaceable></arg>

	    <arg choice="opt">
	      -type

	      <group choice="req">
		<arg choice="req">exclusive</arg>
		<arg choice="req">multiple</arg>
		<arg choice="req">popup</arg>
	      </group>
	    </arg>

	    <arg choice="opt">
	      -fit
	      <group choice="req">
		<arg choice="req">default</arg>
		<arg choice="req">on</arg>
		<arg choice="req">off</arg>
	      </group>
	    </arg>

	  </cmdsynopsis>

	  <cmdsynopsis>
	    <command>$choicegroupcmd</command>

	    <arg choice="opt">cget
	      <replaceable>-optname</replaceable>
	    </arg>
	    <arg choice="opt">configure
	      <replaceable>-optname</replaceable>
	      <replaceable>optval</replaceable>
	    </arg>

	    <arg choice="opt">
	      append <replaceable>text</replaceable> <arg
		choice="opt"><replaceable>image</replaceable></arg>
	    </arg>

	    <arg choice="opt">delete
	      <replaceable>itemnum</replaceable>
	    </arg>

	    <arg choice="opt">deleteall</arg>

	    <arg choice="opt">
	      insert <replaceable>position</replaceable>
	      <replaceable>text</replaceable> <arg
	      choice="opt"><replaceable>image</replaceable></arg>
	    </arg>

	    <arg choice="opt">itemcget
	      <replaceable>itemnum</replaceable>
	      <replaceable>-option</replaceable>
	    </arg>

	    <arg choice="opt">itemconfigure
	      <replaceable>itemnum</replaceable>
	      <replaceable>-option</replaceable>
	      <replaceable>value</replaceable>
	    </arg>

	    <arg choice="opt">selection
	      <group choice="req">
		<arg choice="req">clear
		  <arg choice="opt"><replaceable>index</replaceable></arg>
		</arg>
		<arg choice="req">index</arg>
		<arg choice="req">get</arg>
		<arg choice="req">gettext</arg>
		<arg choice="req">set <option><replaceable>index</replaceable></option></arg>
	      </group>
	    </arg>

	    <arg choice="opt">size</arg>

	  </cmdsynopsis>

	  <note>
	    <para>
	      Choicegroups also utilize the common "item" options, described
	      here: <link linkend="lcdui_item_options">lcdui item options</link>
	    </para>
	  </note>

	</refsynopsisdiv>

	<refsect1>
	  <title>Description</title>
	  <para>
	    The <command>lcdui.choicegroup</command> command creates a
	    "ChoiceGroup" widget that can be added to a form.  A
	    ChoiceGroup is a list of options that can be selected.
	    ChoiceGroups come in three forms: radio buttons (the
	    <option>exclusive</option> type), where only one at a time
	    may be selected, check boxes (the
	    <option>multiple</option> type), or as a popup.  (check
	    boxes).  For an in-depth look at the Java code that this
	    command is based on, see:
	    <link xl:href="http://java.sun.com/javame/reference/apis/jsr118/javax/microedition/lcdui/ChoiceGroup.html">javax.microedition.lcdui.ChoiceGroup</link>
	  </para>
	  <para>
	    The options describing the choicegroup are as follows:
	  </para>
	  <itemizedlist>
	    <listitem>
	      <para><option>-label</option>: Labels the choicegroup
		with the supplied text.
	      </para>
	    </listitem>

	    <listitem>
	      <para><option>-type</option>: Determines the type of the
		chiocegroup, which can be one of
		<option>multiple</option> (check boxes),
		<option>exclusive</option> (radio buttons), or a
		<option>popup</option>
	      </para>
	    </listitem>

	    <listitem>
	      <para>
		<option>-fit</option>: Specifies the type of
		word-wrapping desired.  <option>default</option> means
		that the application has no preferences and that the
		default can be used.  The <option>on</option> option
		means that text wrapping should be performed to fit
		long lines.  The <option>off</option> option means
		that text wrapping should not be performed and that
		long lines will be truncated, and there should be some
		indication of this truncation such as an ellipsis.
	      </para>
	    </listitem>
	  </itemizedlist>
	  <para>
	    The <command>lcdui.choicegroup</command> command returns
	    an object that is itself a command, and can be called with
	    several subcommands:
	  </para>
	  <itemizedlist>
	    <listitem>
	      <para><command>append</command>: Appends the given text
		to the choicegroup as one of the possible selections.
		Optionally, an image (as generated by
		<command>lcdui.image</command> may also be specified.
	      </para>
	    </listitem>

	    <listitem>
	      <para><command>delete</command>: Deletes the item
		specified by
		<option><replaceable>itemnum</replaceable></option>
	      </para>
	    </listitem>

	    <listitem>
	      <para>
		<command>deleteall</command>:
		Deletes all items in the given choicegroup.
	      </para>
	    </listitem>

	    <listitem>
	      <para><command>insert</command>: Inserts the given text,
	      and optional image at
	      <option><replaceable>position</replaceable></option>
	      </para>
	    </listitem>

	    <listitem>
	      <para>
		<command>itemcget</command>: Given an item and an
		<option><replaceable>-option</replaceable></option>,
		which can be one of <option>-font</option>,
		<option>-text</option>, <option>-image</option>,
		<option>-selected</option>, returns the requested
		information, with <option>-selected</option> returning
		1 if the item is selected, 0 if it isn't.
	      </para>
	    </listitem>

	    <listitem>
	      <para><command>itemconfigure</command>: Instead of
	      returning information about the options listed above,
	      sets the specified option for the given item.</para></listitem>

	    <listitem>
	      <para>
		<command>selection</command>: Used with a
		subcommand of its own, which can be one of:
		<itemizedlist>
		  <listitem>
		    <para>
		      <command>get</command>: Returns a list of integers
		      indicating which elements are selected.
		    </para>
		  </listitem>
		  <listitem>
		    <para>
		      <command>gettext</command>: Returns the text of
		      the selected element.
		    </para>
		  </listitem>
		  <listitem>
		    <para>
		      <command>set</command>: Selects the specified item.
		    </para>
		  </listitem>
		  <listitem>
		    <para>
		      <command>clear</command>: Clears the selection
		      from the given item, or, if no
		      <replaceable>itemnum</replaceable> is given,
		      clears all selected items.
		    </para>
		  </listitem>
		</itemizedlist>
	      </para>
	    </listitem>

	    <listitem>
	      <para><command>size</command>: Returns the number of
		elements in the choicegroup.
	      </para>
	    </listitem>
	  </itemizedlist>

	</refsect1>
	<refsect1>
	  <title>Example</title>
	  <programlisting>
set choicegroup [lcdui.choicegroup -label "60ies bands"]
$choicegroup append "Beatles"
$choicegroup append "Beach Boys"
$choicegroup append "Rolling Stones"
set form [lcdui.form -title "ChoiceGroup example form"]
$form append "Pick one:"
$form append $choicegroup
$form setcurrent
	  </programlisting>
	  <para>
	    Live example: <link xl:href="http://www.heclbuilder.com/scripts/show/143" />
	  </para>
	</refsect1>
      </refentry>

      <refentry xml:id="lcdui_command">
	<refnamediv>
	  <refname>lcdui.command</refname>
	  <refpurpose>Creates a command that can be attached to a screen</refpurpose>
	</refnamediv>
	<refsynopsisdiv>
	  <cmdsynopsis>
	    <command>lcdui.command</command>

	    <arg choice="opt">
	      -label
	      <replaceable>label</replaceable>
	    </arg>

	    <arg choice="opt">
	      -longlabel
	      <replaceable>label</replaceable>
	    </arg>

	    <arg choice="opt">
	      -priority
	      <replaceable>priority</replaceable>
	    </arg>

	    <arg choice="opt">
	      -type
	      <group choice="req">
		<arg choice="req">back</arg>
		<arg choice="req">cancel</arg>
		<arg choice="req">exit</arg>
		<arg choice="req">help</arg>
		<arg choice="req">item</arg>
		<arg choice="req">ok</arg>
		<arg choice="req">screen</arg>
		<arg choice="req">stop</arg>
	      </group>
	    </arg>

	  </cmdsynopsis>
	</refsynopsisdiv>
	<refsect1>
	  <title>Description</title>
	  <para>
	    The <command>lcdui.command</command> command creates a
	    command that can be attached to a Screen or an Item.  For
	    an in-depth look at the Java code that this command is
	    based on, see: <link xl:href="http://java.sun.com/javame/reference/apis/jsr118/javax/microedition/lcdui/Command.html">javax.microedition.lcdui.Command</link>
	  </para>
	  <para>
	    The options describing the choicegroup are as follows:
	  </para>
	  <itemizedlist>
	    <listitem>
	      <para><option>-label</option>: A short label for the
	      command, which should be as short as possible.</para>
	    </listitem>

	    <listitem>
	      <para><option>-longlabel</option>: A long, more
	      descriptive label.</para>
	    </listitem>

	    <listitem>
	      <para><option>-priority</option>: A positive number
	      indicating the order of appearance of commands, 1 being
	      the highest priority.</para>
	    </listitem>

	    <listitem>
	      <para><option>-type</option>: Indicates the type of
	      command.  The command types are documented <link xl:href="http://java.sun.com/javame/reference/apis/jsr118/javax/microedition/lcdui/Command.html#field_summary">here</link>
              </para>
	    </listitem>

	  </itemizedlist>

	</refsect1>
	<refsect1>
	  <title>Example</title>
	  <programlisting>
set exitcmd [lcdui.command -label Exit -longlabel Exit \
    -type exit -priority 2]
set backcmd [lcdui.command -label Back -longlabel Back \
    -type back -priority 1]
set addtextcmd [lcdui.command -label AddText -longlabel AddText \
    -type screen -priority 1]

proc NewForm {} {
    global exitcmd
    global backcmd
    global addtextcmd
    set form [lcdui.form -title "Commands" -commandaction HandleCmd]
    $form setcurrent
    $form addcommand $exitcmd
    $form addcommand $backcmd
    $form addcommand $addtextcmd
}

proc HandleCmd {cmd form} {
   global exitcmd
   global backcmd
   if { eq $cmd $backcmd } {
   	NewForm
   } elseif { eq $cmd $exitcmd } {
   	[lcdui.alert -title "Goodbye" -text "Goodbye!" -type info \
            -timeout forever] setcurrent
        after 1000 midlet.exit
   }
   $form append "Blah blah"
}

NewForm
	  </programlisting>

	  <para>
	    Live example: <link xl:href="http://www.heclbuilder.com/scripts/show/144" />
	  </para>
	</refsect1>
      </refentry>

      <refentry xml:id="lcdui_date">
	<refnamediv>
	  <refname>lcdui.date</refname>
	  <refpurpose>Date/Time widget for lcdui forms</refpurpose>
	</refnamediv>
	<refsynopsisdiv>
	  <cmdsynopsis>
	    <command>lcdui.date</command>

	    <arg choice="opt">
	      -date
	      <replaceable>date/time in seconds</replaceable>
	    </arg>

	    <arg choice="opt">
	      -label
	      <replaceable>label</replaceable>
	    </arg>

	    <arg choice="opt">
	      -type
	      <group choice="req">
		<arg choice="req">date</arg>
		<arg choice="req">date_time</arg>
		<arg choice="req">time</arg>
	      </group>
	    </arg>

	  </cmdsynopsis>

	  <cmdsynopsis>
	    <command><replaceable>$datecmd</replaceable></command>

	    <arg choice="opt">cget
	      <replaceable>-optname</replaceable>
	    </arg>
	    <arg choice="opt">configure
	      <replaceable>-optname</replaceable>
	      <replaceable>optval</replaceable>
	    </arg>
	  </cmdsynopsis>

	  <note>
	    <para>
	      Date fields also utilize the common "item" options, described
	      here: <link linkend="lcdui_item_options">lcdui item options</link>
	    </para>
	  </note>

	</refsynopsisdiv>
	<refsect1>
	  <title>Description</title>
	  <para>
	    The <command>lcdui.date</command> command creates a widget
	    that can either display, or allow the user to enter a
	    date, a time, or both.  For
	    an in-depth look at the Java code that this command is
	    based on, see: <link xl:href="http://java.sun.com/javame/reference/apis/jsr118/javax/microedition/lcdui/DateField.html">javax.microedition.lcdui.DateField</link>
	  </para>
	  <para>The <command>lcdui.date</command> command takes these
	  options:</para>
	  <itemizedlist>
          <listitem>
	      <para><option>-label</option>: A label for the date widget.
              </para>
	    </listitem>
	    <listitem>
	      <para><option>-type</option>: One of
	      <option>date</option>, which only displays a date
	      selection widget, <option>time</option>, which only
	      displays a time selection widget, or
	      <option>date_time</option>, which allows the user to
	      select both a date and a time.
              </para>
	    </listitem>
	    <listitem>
	      <para><option>-date</option>: The current time,
	      expressed in milliseconds.
              </para>
	    </listitem>
	  </itemizedlist>
	</refsect1>

	<refsect1>
	  <title>Example</title>
	  <programlisting>
set date [lcdui.date -label "Current date and time:" \
    -date [clock time] -type date_time]
set form [lcdui.form -title "Date Form"]
$form append $date
$form setcurrent
	  </programlisting>

	  <para>
	    Live example: <link xl:href="http://www.heclbuilder.com/scripts/show/144" />
	  </para>
	</refsect1>
      </refentry>

      <refentry xml:id="lcdui_event">
	<refnamediv>
	  <refname><replaceable>$eventcmd</replaceable></refname>
	  <refpurpose>Command/object describing a Canvas event.</refpurpose>
	</refnamediv>
	<refsynopsisdiv>
	  <cmdsynopsis>
	    <command><replaceable>$eventcmd</replaceable></command>
	    <arg choice="opt">cget
	      <replaceable>-optname</replaceable>
	    </arg>
	    <arg choice="opt">configure
	      <replaceable>-optname</replaceable>
	      <replaceable>optval</replaceable>
	    </arg>
	  </cmdsynopsis>
	</refsynopsisdiv>
	<refsect1>
	  <title>Description</title>
	  <para>
	    The
	    <command><replaceable>$eventcmd</replaceable></command>
	    command is used to access information about events
	    received by a Canvas.  There is no Hecl command to create
	    event commands - they are passed in as arguments to the
	    <option>-eventhandler</option> specified for an
	    <command>lcdui.canvas</command>.
	  </para>
	  <para>There are a number of parameters that can be
	  queried:</para>
	  <itemizedlist>
	    <listitem>
	      <para><option>-canvas</option>: Returns the canvas
	      command associated with the event's canvas.</para>
	    </listitem>
	    <listitem>
	      <para><option>-reason</option>: A number representing
		one of the following reasons:
              </para>
	      <programlisting>
    public static final int E_NONE = 0;
    public static final int E_PAINT = 1;
    public static final int E_PPRESS = 2;
    public static final int E_PRELEASE = 3;
    public static final int E_PDRAG = 4;
    public static final int E_KPRESS = 5;
    public static final int E_KRELEASE = 6;
    public static final int E_KREPEAT = 7;
    public static final int E_HIDE = 8;
    public static final int E_SHOW = 9;
    public static final int E_RESIZE = 10;
    public static final int E_UNKNOWN = -1;
	      </programlisting>
	      <para>Which correspond to:</para>
	      <itemizedlist>
		<listitem>
		  <para><constant>E_PAINT</constant>: Used when the
		    Canvas' <methodname>paint</methodname> method is
		    called.</para>
		</listitem>

		<listitem>
		  <para><constant>E_PRESS</constant>: Used when the
		    Canvas' <methodname>pointerPressed</methodname>
		    method is called.
		  </para>
		</listitem>

		<listitem>
		  <para><constant>E_PRELEASE</constant>: Used when
		    the Canvas'
		    <methodname>pointerReleased</methodname> method is
		    called.
		  </para>
		</listitem>

		<listitem>
		  <para><constant>E_PDRAG</constant>: Used when
		    the Canvas'
		    <methodname>pointerDragged</methodname> method is
		    called.
		  </para>
		</listitem>

		<listitem>
		  <para><constant>E_KPRESS</constant>: Used when the
		    Canvas' <methodname>keyPressed</methodname> method
		    is called.
		  </para>
		</listitem>

		<listitem>
		  <para><constant>E_KRELEASE</constant>: Used when the
		    Canvas' <methodname>keyReleased</methodname> method
		    is called.
		  </para>
		</listitem>

		<listitem>
		  <para><constant>E_KREPEAT</constant>: Used when the
		    Canvas' <methodname>keyRepeated</methodname> method
		    is called.
		  </para>
		</listitem>

		<listitem>
		  <para><constant>E_HIDE</constant>: Used when the
		    Canvas' <methodname>hideNotify</methodname> method
		    is called.
		  </para>
		</listitem>

		<listitem>
		  <para><constant>E_SHOW</constant>: Used when the
		    Canvas' <methodname>showNotify</methodname> method
		    is called.
		  </para>
		</listitem>
		<listitem>
		  <para><constant>E_RESIZE</constant>: Used when the
		    Canvas' <methodname>sizeChanged</methodname>
		    method is called.
		  </para>
		</listitem>
		<listitem>
		  <para><constant>E_UNKNOWN</constant>: Used to
		  signify an unknown event.
		  </para>
		</listitem>
	      </itemizedlist>
	    </listitem>

	    <listitem>
	      <para><option>-x</option>: The x coordinate of the event.
              </para>
	    </listitem>

	    <listitem>
	      <para><option>-y</option>: The y coordinate of the event.
              </para>
	    </listitem>

	    <listitem>
	      <para><option>-width</option>: The width of the screen
	      area covered by the event.
              </para>
	    </listitem>

	    <listitem>
	      <para><option>-height</option>: The height of the screen
	      area covered by the event.
              </para>
	    </listitem>

	    <listitem>
	      <para><option>-keycode</option>: An integer referencing
	      the key involved in the event.
              </para>
	      <note>
		<para>
		  Be aware that different phones may use different
		  numbers.
		</para>
	      </note>
	    </listitem>

	    <listitem>
	      <para><option>-keyname</option>: Returns a string giving
		a cross platform name for the key pressed.  Names are
		given here: <link xl:href="http://java.sun.com/javame/reference/apis/jsr118/javax/microedition/lcdui/Canvas.html#field_summary"
		/>, with the addition of "LEFT_SK" and "RIGHT_SK" for
		the left and right soft keys These only occur when in
		full screen mode and the soft key events go to the
		program)
              </para>
	    </listitem>

	    <listitem>
	      <para><option>-gameaction</option>: Returns the integer
	      code for the game action.  Described in further detail
	      here:
		<link xl:href="http://java.sun.com/javame/reference/apis/jsr118/javax/microedition/lcdui/Canvas.html#gameactions"></link>
              </para>
	    </listitem>

	  </itemizedlist>
	</refsect1>
	<refsect1>
	  <title>Example</title>
	  <para>
	    See the example script in the midp20/ directory.  <link xl:href="http://github.com/davidw/hecl/blob/master/midp20/script.hcl"></link>
	  </para>
	</refsect1>
      </refentry>

      <refentry xml:id="lcdui_font">
	<refnamediv>
	  <refname>lcdui.font</refname>
	  <refpurpose>Font information and manipulation command.</refpurpose>
	</refnamediv>
	<refsynopsisdiv>
	  <cmdsynopsis>
	    <command>lcdui.font</command>
	    <arg choice="opt">names</arg>
	    <group choice="opt">
	      <replaceable>fontname</replaceable>
	      <arg choice="req">cget</arg>
	      <group choice="req">
		<arg choice="req">-face</arg>
		<arg choice="req">-size</arg>
		<arg choice="req">-plain</arg>
		<arg choice="req">-bold</arg>
		<arg choice="req">-italic</arg>
		<arg choice="req">-underlined</arg>
		<arg choice="req">-height</arg>
		<arg choice="req">-baselineposition</arg>
	      </group>
	    </group>
	    <arg choice="opt">
	      <replaceable>fontname</replaceable>
	      charwidth
	      <replaceable>string</replaceable>
	      <arg
		choice="opt">
		<replaceable>offset</replaceable>
		<arg choice="opt"><replaceable>length</replaceable>
	      </arg>
	      </arg>
	    </arg>

	    <arg choice="opt">
	      <replaceable>fontname</replaceable>
	      stringwidth
	      <replaceable>string</replaceable>
	      <arg
		choice="opt"><replaceable>offset</replaceable>
		<arg choice="opt"><replaceable>length</replaceable>
		</arg>
	      </arg>
	    </arg>

	  </cmdsynopsis>
	</refsynopsisdiv>
	<refsect1>
	  <title>Description</title>
	  <para>
	    The <command>lcdui.font</command> command is used to fetch
	    information about fonts.  For an in-depth look at the Java
	    code that this command is based on, see: <link xl:href="http://java.sun.com/javame/reference/apis/jsr118/javax/microedition/lcdui/Font.html">javax.microedition.lcdui.Font</link>
	  </para>
	  <para>
	    It accepts several subcommands:
	  </para>
	  <itemizedlist>
	    <listitem>
	      <para><command>names</command>: Returns a list of all
	      the available fonts.</para>
	    </listitem>

	    <listitem>
	      <para><replaceable>fontname</replaceable>
		<command>charwidth</command>
		<option><replaceable>string</replaceable></option>:
		Returns the width, in pixels, of the given characters.
		Takes optional
		<option><replaceable>offset</replaceable></option> and
		<option><replaceable>length</replaceable></option>
		parameters.
              </para>
	    </listitem>

	    <listitem>
	      <para><replaceable>fontname</replaceable>
		<command>stringwidth</command>
		<option><replaceable>string</replaceable></option>:
		Returns the width, in pixels, of the given string.
		Takes optional
		<option><replaceable>offset</replaceable></option> and
		<option><replaceable>length</replaceable></option>
		parameters.
              </para>
	    </listitem>

	    <listitem>
	      <para><replaceable>fontname</replaceable>
		<command>cget</command>
		<option><replaceable>-option</replaceable></option>:
		Used to fetch information about a font.  Allowed
		options are as follows:
              </para>
	      <itemizedlist>
		<listitem>
		  <para><option>-face</option>: One of "system",
		  "proportional", or "monospace".
		  </para>
		</listitem>
		<listitem>
		  <para><option>-size</option>: One of "small",
		  "medium" or "large".
		  </para>
		</listitem>

		<listitem>
		  <para><option>-plain</option>: Returns a 1 if the
		  font is "plain" - not bold, underlined or italic, or
		  0 if it isn't.
		  </para>
		</listitem>

		<listitem>
		  <para><option>-bold</option>: Returns 1 or 0 if the
		  font is bold or not.
		  </para>
		</listitem>

		<listitem>
		  <para><option>-italic</option>: Returns 1 or 0 if the
		  font is italic or not.
		  </para>
		</listitem>

		<listitem>
		  <para><option>-underlined</option>: Returns 1 or 0 if the
		  font is underlined or not.
		  </para>
		</listitem>

		<listitem>
		  <para><option>-height</option>: Returns the standard
		  height of a line of text in this font, in pixels.
		  </para>
		</listitem>

		<listitem>
		  <para><option>-baselineposition</option>: Returns
		  the distance in pixels from the top of the text to
		  the text's baseline.
		  </para>
		</listitem>
	      </itemizedlist>
	    </listitem>

	  </itemizedlist>
	</refsect1>
	<refsect1>
	  <title>Example</title>
	  <programlisting>
set form [lcdui.form -title "Font examples"]

$form setcurrent

foreach f [sort [lcdui.font names]] {
    set s [lcdui.stringitem -text $f]
    $s configure -font $f
    $form append $s
}
	  </programlisting>
	  <para>
	    Live example: <link xl:href="http://www.heclbuilder.com/scripts/show/147" />
	  </para>

	</refsect1>
      </refentry>

      <refentry xml:id="lcdui_form">
	<refnamediv>
	  <refname>lcdui.form</refname>
	  <refpurpose>Creates a form that can contain various widgets</refpurpose>
	</refnamediv>
	<refsynopsisdiv>
	  <cmdsynopsis>
	    <command>lcdui.form</command>
	    <arg choice="opt">-title <replaceable>title</replaceable></arg>
	    <arg choice="opt">-ticker <replaceable>tickerwidget</replaceable></arg>
	    <arg choice="opt">-commandaction <replaceable>commandActionProc</replaceable></arg>
	  </cmdsynopsis>

	  <cmdsynopsis>
	    <command><replaceable>$formcmd</replaceable></command>

	    <arg choice="opt">cget
	      <replaceable>-optname</replaceable>
	    </arg>

	    <arg choice="opt">configure
	      <replaceable>-optname</replaceable>
	      <replaceable>optval</replaceable>
	    </arg>

	    <arg choice="opt">size</arg>

	    <arg choice="opt">append
	      <group choice="req">
		<arg
		choice="req"><replaceable>string</replaceable></arg>
		<arg
		choice="req"><replaceable>image</replaceable></arg>
		<arg
		choice="req"><replaceable>widget</replaceable></arg>
	      </group>
	    </arg>

	    <arg choice="opt">item
	      <replaceable>itemnum</replaceable>
	    </arg>

	    <arg choice="opt">delete
	      <replaceable>itemnum</replaceable>
	    </arg>

	    <arg choice="opt">deleteall
	    </arg>

	    <arg choice="opt">setcurrent
	    </arg>

	  </cmdsynopsis>

	</refsynopsisdiv>
	<refsect1>
	  <title>Description</title>
	  <para>
	    The <command>lcdui.form</command> command creates a form,
	    returning a command/object that can be used to further
	    manipulate the created form.  For an in-depth look at the
	    Java code that this command is based on, see: <link xl:href="http://java.sun.com/javame/reference/apis/jsr118/javax/microedition/lcdui/Form.html">javax.microedition.lcdui.Form</link>
	  </para>
	  <para>The subcommands accepted by the
	    <command><replaceable>$formcmd</replaceable></command>
	    that <command>lcdui.form</command> returns are as follows:
	  </para>
	  <itemizedlist>
	    <listitem>
	      <para><command>cget</command>: Fetch configuration options.
              </para>
	    </listitem>
	    <listitem>
	      <para><command>configure</command>: Set configuration options.
              </para>
	    </listitem>
	    <listitem>
	      <para><command>item</command>
		<option><replaceable>itemnum</replaceable></option>:
		Return the item identified by
		<option><replaceable>itemnum</replaceable></option>.
              </para>
	    </listitem>

	    <listitem>
	      <para><command>delete</command>
		<option><replaceable>itemnum</replaceable></option>:
		Delete the item identified by
		<option><replaceable>itemnum</replaceable></option>.
              </para>
	    </listitem>

	    <listitem>
	      <para><command>deleteall</command>: Delete all items
	      associated with this form.
              </para>
	    </listitem>

	  </itemizedlist>
	</refsect1>
	<refsect1>
	  <title>Example</title>
	  <programlisting>
set choicegroup [lcdui.choicegroup -label Choice -type popup]
foreach x {c1 c2 c3} {
    $choicegroup append $x
}
set ticker [lcdui.ticker -text "I am a Ticker!"]

set form [lcdui.form -title "Example Form"]
$form setcurrent
$form configure -ticker $ticker
$form append [lcdui.textfield -label "TextField" -text "TextField" -uneditable 1]
$form append [lcdui.textfield -label "Editable TextField" -text "editable text"]
$form append [lcdui.imageitem -image $logo -anchor center]
$form append [lcdui.spacer -label spacer1 -minwidth 200 -minheight 2]
$form append [lcdui.stringitem -text "Stringitem"]
$form append [lcdui.spacer -label spacer2 -minwidth 200 -minheight 4]
$form append [lcdui.date -label "Date/Time" -date [clock time]]
$form append $choicegroup
$form append [lcdui.imageitem -image $logo]
$form append [lcdui.gauge -label "How cool is Hecl?" -interactive 1 \
		     -value 10 -maxvalue 10]
	  </programlisting>

	  <para>
	    Live example: <link xl:href="http://www.heclbuilder.com/scripts/show/148" />
	  </para>
	</refsect1>
      </refentry>

      <refentry xml:id="lcdui_gauge">
	<refnamediv>
	  <refname>lcdui.gauge</refname>
	  <refpurpose>Creates a gauge widget that can be attached to a
	  form.</refpurpose>
	</refnamediv>
	<refsynopsisdiv>
	  <cmdsynopsis>
	    <command>lcdui.gauge</command>

	    <arg choice="opt">-label <replaceable>label</replaceable></arg>
	    <arg choice="opt">-interactive
	      <group choice="req">
		<arg choice="req">1</arg>
		<arg choice="req">0</arg>
	      </group>
	    </arg>
	    <arg choice="opt">-value <replaceable>value</replaceable></arg>
	    <arg choice="opt">-maxvalue <replaceable>maxvalue</replaceable></arg>

	  </cmdsynopsis>

	  <cmdsynopsis>
	    <command><replaceable>$gaugecmd</replaceable></command>

	    <arg choice="opt">cget
	      <replaceable>-optname</replaceable>
	    </arg>

	    <arg choice="opt">configure
	      <replaceable>-optname</replaceable>
	      <replaceable>optval</replaceable>
	    </arg>
	  </cmdsynopsis>

	  <note>
	    <para>
	      Gauge items also utilize the common "item" options, described
	      here: <link linkend="lcdui_item_options">lcdui item options</link>
	    </para>
	  </note>

	</refsynopsisdiv>
	<refsect1>
	  <title>Description</title>
	  <para>
	    The <command>lcdui.gauge</command> command creates a gauge element, and returns a
	    command/object that can be used to manipulate it. For an in-depth look at the Java code
	    that this command is based on, see: <link xl:href="http://java.sun.com/javame/reference/apis/jsr118/javax/microedition/lcdui/Gauge.html">javax.microedition.lcdui.Gauge</link>
	  </para>
	  <para>The options for this command are as follows:</para>
	  <itemizedlist>
	    <listitem>
	      <para><option>-value</option>: An integer giving the initial value of the gauge, or,
	      one of these special values: "continuous-idle", "continuous-running",
	      "incremental-idle", or "incremental-updating".  These values are utilized for
	      non-interactive guages that can be used as progress meters.  These values are
	      explained in further detail on the javadoc page linked above.
              </para>

	      <para><option>-maxvalue</option>: An integer giving the maximum value of the guage, or
	      "indefinite" if there is no maximum value.
              </para>

	      <para><option>-interactive</option>: Either 1 or 0, depending on whether the gauge is
	      interactive, or is for display purposes only.
              </para>
	    </listitem>
	  </itemizedlist>
	</refsect1>
	<refsect1>
	  <title>Example</title>
	  <programlisting>
set form [lcdui.form -title "Gauge Example"]
$form append [lcdui.gauge -label "From 1 to 10" -interactive 1 \
		     -value 6 -maxvalue 10]
$form setcurrent
	  </programlisting>

	  <para>
	    Live example: <link xl:href="http://www.heclbuilder.com/scripts/show/149" />
	  </para>
	</refsect1>
      </refentry>

      <refentry xml:id="lcdui_image">
	<refnamediv>
	  <refname>lcdui.image</refname>
	  <refpurpose>Creates an image.</refpurpose>
	</refnamediv>
	<refsynopsisdiv>
	  <cmdsynopsis>
	    <command>lcdui.image</command>
	    <arg choice="opt">
	      -file <replaceable>filename</replaceable>
	    </arg>

	    <arg choice="opt">
	      -rms <replaceable>recordstore</replaceable>
	    </arg>

	    <arg choice="opt">
	      -resource <replaceable>resourcename</replaceable>
	    </arg>

	    <arg choice="opt">
	      -image <replaceable>image</replaceable>
	    </arg>

	    <arg choice="opt">
	      -data <replaceable>data</replaceable>
	    </arg>

	  </cmdsynopsis>

	  <cmdsynopsis>
	    <command>$imagecmd</command>
	    <arg choice="opt">cget
	      <replaceable>-optname</replaceable>
	    </arg>

	    <arg choice="opt">configure
	      <replaceable>-optname</replaceable>
	      <replaceable>optval</replaceable>
	    </arg>

	    <arg choice="opt">thumbnail
	      <arg choice="opt">thumbwidth
		<arg choice="opt">thumbwidth</arg>
	      </arg>
	    </arg>

	    <arg choice="opt">graphics</arg>
	  </cmdsynopsis>

	</refsynopsisdiv>
	<refsect1>
	  <title>Description</title>
	  <para>
	    The <command>lcdui.image</command> command creates an image, from some data, either by
	    indicating a filename, record store, or a resource name.  It returns an object/command
	    that can be utilized to manipulate the image.  Mutable images are those loaded from
	    existing data, generally.  Immutable images are created as a "blank slate", with white
	    pixels.  For an in-depth look at the Java code that this command is based on, see:
	    <link xl:href="http://java.sun.com/javame/reference/apis/jsr118/javax/microedition/lcdui/Image.html">javax.microedition.lcdui.Image</link>

	  </para>
	  <para>
	    The options available for the <command>lcdui.image</command> command are described
	    below:
	  </para>
	  <itemizedlist>
	    <listitem>
	      <para><option>-file</option>: Load the image from the given file name.
              </para>
	    </listitem>

	    <listitem>
	      <para><option>-rms</option>: Load the image from the given record store.
              </para>
	    </listitem>

	    <listitem>
	      <para><option>-resource</option>: Load the image from the given resource.  By
	      "resource", we mean a file included in the .jar.
              </para>
	    </listitem>

	    <listitem>
	      <para><option>-image</option>: Create a new image from an existing image.
              </para>
	    </listitem>

	    <listitem>
	      <para><option>-data</option>: Create a new image from binary data.
              </para>
	    </listitem>
	  </itemizedlist>

	  <para>
	    The subcommands available to an <command><replaceable>$imagecmd</replaceable></command>
	    are listed below:
	  </para>

	  <itemizedlist>
	    <listitem>
	      <para><command>thumbnail</command>: Creates a thumbnail from the image.
              </para>
	    </listitem>

	    <listitem>
	      <para><command>graphics</command>: Unless the image is immutable, creates and returns
	      a new graphics object associated with the image.
              </para>
	    </listitem>
	  </itemizedlist>

	</refsect1>

	<refsect1>
	  <title>Creating base64 encoded images</title>

	  <para>
	    There are two ways to include images in Hecl applications.  One is to add the image to
	    the .jar file itself.  The second is to include it directly in the script, as a base64
	    included string.  Here's how to do so on a Linux machine:
	  </para>

	  <procedure>
	    <step>
	      <para>
		Create an image.  For example, with "The Gimp", an image manipulation program on
		Linux, you might create a PNG, <filename>x.png</filename>.
	      </para>
	    </step>

	    <step>
	      <para>
		Now you need to turn the binary PNG file into a string that can be included in a script:
	      </para>
	      <screen>base64 &lt; x.png &gt; x.txt</screen>
	    </step>

	    <step>
	      <para>Now copy and paste x.txt into your script, like in the script below</para>
	    </step>

	  </procedure>

	</refsect1>


	<refsect1>
	  <title>Example</title>
	  <programlisting>
# base64 encoded PNG
set data {iVBORw0KGgoAAAANSUhEUgAAAGQAAABkCAYAAABw4pVUAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A
/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB9gKGBQIB6A2RzQAAAAZdEVYdENv
bW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAAG40lEQVR42u2dW0hUXRTH98w4Upk145gylRb1
YOhMNyIigkC65/2WYCARhgS9RXTDCHqyIiF66e7dHiywIBB66cHoQhko9DAP0zTpjIo4WJTp+O/J
j+/rM/caZ85tXH84b+fsvdb6edaZfc5aWxMACJZuZOYQMBAWA2EgLAbCQFgMhIGwGAgDYTEQFgNh
ICwGwkBYDISBsBgIA2EtKCDl5eXCZDLNeaxfv158//5ds0B8+/ZNrFu3TmpnRUWFsoZABQ0NDSE1
NRVCiDmPkydPQivV1tZK7VuxYgWGhoYUtUOo5XBHR4fUYZPJhBcvXqgOo7u7W2qbEAKPHj1S3Bah
puMlJSVSp9euXYvx8XHVbAqFQsjIyJDaVVZWpoo9qgIJBoNwOBxS50+cOKGaTceOHZPak5qaqniq
0gQIALS1tZHSQ3d3t+K2PHv2jGRLR0eHavFRHQgAFBUVSYOQkZGBUCikmA2jo6NwOp1SO0pLS1WN
jSZAAoEAUlJSpME4fvy4YjZUVVWRUlUwGIx/IADQ0tJCShfPnz+P+dyPHz8mzd3e3q56XDQDAgAF
BQXSoKxatQpjY2Mxm3N4eBhpaWnSeUtKSjSJiaZABgcHYbfbpcGprq6O2ZxlZWXS+RwOh+qpShdA
AKCpqYmUPp4+fRr1XO3t7aS52traNIuH5kAAIC8vTxokp9OJ0dHRqO5Gyg+J4uJiTWOhCyBfv36F
zWaTBquqqkrR55XD4UAgEGAgAPDw4UNSOnny5EnEYzc2NpLGbm1t1TwOugECAIcOHZIGLT09HSMj
I+Qx/X4/6e4rKirSRQx0BYQavMrKSvKYBw4ckI6XkpKiearSJRAAePDgASm9dHZ2Sse6ffs2aayW
lhbd+K87INTUlZaWhuHh4b+O4fV6kZycLB2nsLBQV77rEojf78fy5culwSwvL5/1+unpaeTm5pJS
1eDgIAOh6N69e/N+NX7z5k3Stc3NzbrzW7dAqA/kP9/IejweJCUlSa8rKCjQpc+6BuLz+bBs2TLy
6jocDmPXrl3S8+12u+5SlSGAAMCdO3fIi7rr16+Tzm1qatKtv7oHAgD79u0j/dUvWrRIel5+fr6u
fTUB+t98xufzCZfLJcbHx6Max263i/7+fuF0OrmUNBplZmaKa9euRT1OQ0ODrmGoVrkYK+3Zs4f0
jJjtyMvLM4SPhkhZM/r8+bNwu90Rpy6bzSb6+/vFypUrudg6llqzZo2or6+fV6oyAgzDpayZ1yI7
d+4kp6rDhw8byj9DpSwhhPD7/cLlcolQKCQ912KxCK/XK1avXs39IUqppqaGBEMIIcLhsOjq6jKW
g0a6nakvHP99JCcnw+fzGcZHwwChvpI3+nPEMEAOHjw47zWI1rVWcQfk/v37UcGYaUeLpDiCgcyR
qiiFD5Tj6NGjDCRaUb6vb926FZWVlZpV0y8YIJQKFKvVio8fP2JkZATp6enS8zMzM1XtYYwbINTy
0suXL/9zTWdnJ+kuOXXqFAOJVJQC7M2bN2NycvI/11VUVEivM5vN6OnpYSBUUep8rVYrent7/3ct
dZOC7OxsTExMMBCZBgYGSE08ly5d+usY1D6Quro6BiJTfn6+NJCbNm3Cr1+/5hyH0umbmJiIvr4+
BvI3UbqprFYrPnz4IB2L2i63Y8cOhMNhBjLfVBVJmqH2hTQ0NDCQP0XpcNq4caM0Vc1nYZmUlASv
18tAZtTc3CwNWkJCAt6/fx/x2F++fCFVP+7fv5+BRJLrL168OO85qNWPjY2NDKSwsFAaKLfbHfWa
Ye/evaT2BK3603UBhLK9RkJCAt69exf1XF6vF0uXLpXOd+TIkYUJhNo3fuHChZjNeevWLVLq6urq
WnhAKAs3l8sV09cb09PT2L17N2l/FSW3htIdkNbWVmlQLBYL3r59G/O5PR4PlixZIp2/trZ2YQAJ
BAKkbf7OnTunmA03btwgbcj58uXL+AdSXFwsDUZOTg5+/vypmA3hcJhU/ZiVlaWoHZoDoey3aLFY
8ObNG8Vt+fTpE6nB5/z58/EJhLoj6dmzZ1Vzvr6+nvSze7bvLoYHQtmzNzs7W9UUMTU1he3bt0vt
2rZtG6ampuIHCOWDkcViwevXr1V/iPb19SExMVFq39WrV+MDSDAYJH1SPXPmjGaLsStXrkjtW7x4
MTwej/GBlJaWSp3dsGEDfvz4oRmQyclJbNmyRWpnbm6usYFQNuA3m8149eqV1u840dvbC6vVKrX3
7t27xgRCrf44ffo09KK6ujqpvTabDQMDA8YDQtmONSsrS9NU9acmJibgdrs13dPXcC1t/C+PWAyE
gbAYCIuBMBAWA2EgLAbCQFgMhIGwGAhrFv0GfQwoE8oHj1AAAAAASUVORK5CYII=}

set logo [lcdui.image -resource /hecl_logo.png]
set ximg [lcdui.image -data [base64::decode $data]]
set form [lcdui.form -title "Show Image"]
$form append $logo
$form append $ximg
$form setcurrent
	  </programlisting>

	  <para>
	    Live example: <link xl:href="http://www.heclbuilder.com/scripts/show/150" />
	  </para>

	</refsect1>
      </refentry>

      <refentry xml:id="lcdui_imageitem">
	<refnamediv>
	  <refname>lcdui.imageitem</refname>
	  <refpurpose>An item that can contain an image, in order to attach it to a form.</refpurpose>
	</refnamediv>
	<refsynopsisdiv>
	  <cmdsynopsis>
	    <command>lcdui.imageitem</command>
	    <arg choice="opt">-appearance
	      <group choice="req">
		<arg choice="req">plain</arg>
		<arg choice="req">button</arg>
		<arg choice="req">hyperlink</arg>
	      </group>
	    </arg>
	    <arg choice="opt">-image <replaceable>image</replaceable></arg>
	    <arg choice="opt">-label <replaceable>label</replaceable></arg>
	    <arg choice="opt">-text <replaceable>text</replaceable></arg>
	  </cmdsynopsis>

	  <cmdsynopsis>
	    <command><replaceable>$imageitemcmd</replaceable></command>
	    <arg choice="opt">cget
	      <replaceable>-optname</replaceable>
	    </arg>

	    <arg choice="opt">configure
	      <replaceable>-optname</replaceable>
	      <replaceable>optval</replaceable>
	    </arg>
	  </cmdsynopsis>

	  <note>
	    <para>
	      Image items also utilize the common "item" options, described
	      here: <link linkend="lcdui_item_options">lcdui item options</link>
	    </para>
	  </note>

	</refsynopsisdiv>
	<refsect1>
	  <title>Description</title>
	  <para>
	    The <command>lcdui.imageitem</command> command creates an item holding an image, in
	    order to be able to attach an image to a form.  It also returns a command/object that
	    can be used to manipulate the ImageItem.  For an in-depth look at the Java code that
	    this command is based on, see: <link xl:href="http://java.sun.com/javame/reference/apis/jsr118/javax/microedition/lcdui/ImageItem.html">javax.microedition.lcdui.ImageItem</link>
	  </para>
	  <para>The options unique to this command are as follows:</para>
	  <itemizedlist>
	    <listitem>
	      <para><option>-appearance</option>: Specifies the appearance and behavior of the
	      imageitem.  The meaning of the various values is explained in further detail here:
	      <link xl:href="http://java.sun.com/javame/reference/apis/jsr118/javax/microedition/lcdui/Item.html#appearance">javax.microedition.lcdui.Item</link>.
              </para>
	    </listitem>
	  </itemizedlist>
	</refsect1>
      </refentry>

      <refentry xml:id="lcdui_list">
	<refnamediv>
	  <refname>lcdui.list</refname>
	  <refpurpose>Creates a full-screen list</refpurpose>
	</refnamediv>
	<refsynopsisdiv>
	  <cmdsynopsis>
	    <command>lcdui.list</command>
	    <arg choice="opt">-title <replaceable>title</replaceable></arg>
	    <arg choice="opt">-type
	      <group choice="req">
		<arg choice="req">exclusive</arg>
		<arg choice="req">multiple</arg>
		<arg choice="req">implicit</arg>
	      </group>
	    </arg>
	    <arg choice="opt">-selectcommand <replaceable>cmd</replaceable></arg>
	  </cmdsynopsis>
	</refsynopsisdiv>
	<refsect1>
	  <title>Description</title>
	  <para>
	    The <command>lcdui.list</command> command creates a full-screen list and returns a
	    command/object that can be used to manipulate it. For an in-depth look at the Java code
	    that this command is based on, see: <link xl:href="http://java.sun.com/javame/reference/apis/jsr118/javax/microedition/lcdui/List.html">javax.microedition.lcdui.List</link>
	  </para>
	  <para>The options unique to this command are as follows:</para>
	  <itemizedlist>
	    <listitem>
	      <para><option>-type</option>: One of <option>exclusive</option>,
		<option>multiple</option> or <option>implicit</option>.  Exclusive and multiple
		correspond, respectively, to radio buttons and checkboxes.  Implicit lists act like
		a menu, dispatching to the list's <option>-commandaction</option> when a list item
		is selected.
              </para>
	    </listitem>
	    <listitem>
	      <para><option>-selectcommand</option>: Select the command which should be used for
	      implicit list select actions.
              </para>
	    </listitem>
	  </itemizedlist>
	</refsect1>

	<refsect1>
	  <title>Example</title>
	  <programlisting>
set selectcmd [lcdui.command -label Select -longlabel Select -type \
    item -priority 1]
set lst [lcdui.list -title "List Example" -commandaction selectname]
set names {Anna Barbara Carla Daniela Emanuela Federica}
foreach n $names {
    $lst append $n
}
$lst setcurrent
$lst addcommand $selectcmd
proc selectname {cmd lst} {
    global names
    [lcdui.alert -text "Selected: [lindex $names [$lst selection get]]"] \
        setcurrent
}</programlisting>
	  <para>Produces:</para>

	  <para>
	    Live example: <link xl:href="http://www.heclbuilder.com/scripts/show/151" />
	  </para>
	</refsect1>
      </refentry>

      <refentry xml:id="lcdui_settings">
	<refnamediv>
	  <refname>lcdui.settings</refname>
	  <refpurpose>Returns or sets information about the graphical environment.</refpurpose>
	</refnamediv>
	<refsynopsisdiv>
	  <cmdsynopsis>
	    <command>lcdui.settings</command>

	    <arg choice="opt">-color</arg>
	    <arg choice="opt">-alphalevels</arg>

	    <arg choice="opt">-alertimagewidth</arg>
	    <arg choice="opt">-alertimageheight</arg>
	    <arg choice="opt">-listimagewidth</arg>
	    <arg choice="opt">-listimageheight</arg>
	    <arg choice="opt">-choiceimagewidth</arg>
	    <arg choice="opt">-choiceimageheight</arg>

	    <arg choice="opt">-bg</arg>
	    <arg choice="opt">-fg</arg>

	    <arg choice="opt">-hilightbg</arg>
	    <arg choice="opt">-hilightfg</arg>
	    <arg choice="opt">-border</arg>
	    <arg choice="opt">-hilightborder</arg>
	    <arg choice="opt">-borderstyle</arg>
	    <arg choice="opt">-hilightborderstyle</arg>

 	    <arg choice="opt">-cvfullscreen
	      <group choice="opt">
		<arg choice="req">1</arg>
		<arg choice="req">0</arg>
	      </group>
	    </arg>
	    <arg choice="opt">-cvdocmds
	      <group choice="opt">
		<arg choice="req">1</arg>
		<arg choice="req">0</arg>
	      </group>
	    </arg>
	    <arg choice="opt">-cvkeepcmdsinfullscreen
	      <group choice="opt">
		<arg choice="req">1</arg>
		<arg choice="req">0</arg>
	      </group>
	    </arg>
	    <arg choice="opt">-cvcmdbg
	      <arg choice="opt">color</arg>
	    </arg>
	    <arg choice="opt">-cvcmdfg
	      <arg choice="opt">color</arg>
	    </arg>

	    <arg choice="opt">-skleft
	      <arg choice="opt">keycode</arg>
	    </arg>
	    <arg choice="opt">-skright
	      <arg choice="opt">keycode</arg>
	    </arg>

	  </cmdsynopsis>
	</refsynopsisdiv>
	<refsect1>
	  <title>Description</title>
	  <para>
	    The <command>lcdui.settings</command> command returns information about the phone the
	    program is running on.
	  </para>

	  <itemizedlist>
	    <listitem><para><option>-color</option>: is this a color display? 1 or 0</para></listitem>
	    <listitem><para><option>-alphalevels</option>: number of alpha levels</para></listitem>
	    <listitem><para><option>-alertimagewidth</option>: width in pixels of the alert image</para></listitem>
	    <listitem><para><option>-alertimageheight</option>: height in pixels of the alert image</para></listitem>
	    <listitem><para><option>-listimagewidth</option>: width in pixels of the list image</para></listitem>
	    <listitem><para><option>-listimageheight</option>: height in pixels of the list image</para></listitem>
	    <listitem><para><option>-choiceimagewidth</option>: width in pixels of the choice image</para></listitem>
	    <listitem><para><option>-choiceimageheight</option>: height in pixels of the choice image</para></listitem>

	    <listitem><para><option>-bg</option>: background color</para></listitem>
	    <listitem><para><option>-fg</option>: foreground color</para></listitem>

	    <listitem><para><option>-hilightbg</option>: background hilight color</para></listitem>
	    <listitem><para><option>-hilightfg</option>: foreground hilight color</para></listitem>

	    <listitem><para><option>-border</option>: border color</para></listitem>
	    <listitem><para><option>-hilightborder</option>: border hilight color</para></listitem>
	    <listitem><para><option>-borderstyle</option>: border style - can be either DOTTED (1) or SOLID (0)</para></listitem>
	    <listitem><para><option>-hilightborderstyle</option>: border highlight style - can be either DOTTED (1) or SOLID (0)</para></listitem>
 	    <listitem><para><option>-cvfullscreen</option>: Get/set whether full screen mode is allowed for the canvas widget.</para>
	      <para>
		This setting enables the use of fullscreen mode for a canvas. The lcdui
		<classname>Canvas</classname> class behaves different in fullscreen mode: it does
		not show commands. Full screen mode is enabled by default, so a canvas (being a
		subclass of <classname>lcdui.game.GameCanvas</classname>) can be created in
		fullscreen mode. On some devices the behavior in fullscreen mode is broken, so this
		setting gives you the chance to avoid the fullscreen usage without changing the
		application itself but only the application startup that might detect certain phone
		features and turn off fullscreen mode generally for all canvases.
	      </para>
	      <para>
		Devices being picky in fullscreen mode include most of the BlackBerry devices since
		handling of commands is totally different from other Java ME devices. Most
		BlackBerry devices use the dial to select between command entries.
	      </para>
	    </listitem>

	    <listitem><para><option>-cvdocmds</option>: Get/set whether to display commands in the full
	    screen canvas or not.</para>
	      <para>
		Enables the display of commands by the hecl canvas. When it fullscreen mode,
		canvases do not show commands. You may want a canvas in fullscreen mode and wish to
		use commands as usual, so the canvas in hecl provides a fallback mechanism to show
		commands attached to the canvas by itself.
	      </para>
	    </listitem>

	    <listitem><para><option>-cvkeepcmdsinfullscreen</option>: Get/set whether to add commands in full screen mode.</para>
	      <para>
		Enables treatment of commands attached to a canvas even in fullscreen mode. This
		behavior is implemented in the Hecl midp layer and may be slidely different from the
		regular phone behavior for commands attached to other lcdui interafce elements like
		a form or list.The setting has an effect only for a canvas in fullscreen mode and
		enables command handling similar to the command handling of non-fullscreen canvases.
	      </para>
	    </listitem>

	    <listitem>
	      <para>
		<option>-cvcmdbg</option>: Get/set color value for
		command background color in canvas, when Hecl's full
		screen Canvas command handling is enabled (see above).
	      </para>
	    </listitem>

	    <listitem><para><option>-cvcmdfg</option>: Get/set color value for command foreground color in
	      canvas, when Hecl's full screen Canvas command handling is enabled (see above).
	    </para></listitem>

	    <listitem><para><option>-skleft</option>: Get/set the numeric keycode for the left soft key.</para>
	      <para>
		The values are used to identify the keys triggering command handling for a
		canvas. The standard settings for these values are the usual keycode -6 (left) and
		-7 (right) that work on most Java ME devices. There are some well-known differences
		that are detected by the Hecl midp package:
	      </para>
	      <para>
		Siemens S65 and friends: -1 (left), -4 (right) - detected via existence of class
		<classname>com.siemens.mp.lcdui.Image</classname> BlackBerry: 524288=0x80000 (left),
		0x1b0000 (right) - detected via existence of class
		<classname>net.rim.device.api.system.Application</classname>
	      </para>
	      <para>
		Application developers can tailor these settings for specific device models in their
		own applications.
	      </para>
	    </listitem>
	    <listitem><para><option>-skright</option>: Get/set the numeric keycode for the right soft key
	    (see explanation above).</para></listitem>

	  </itemizedlist>

	</refsect1>
	<refsect1>
	  <title>Example</title>
	  <programlisting>
set form [lcdui.form -title "Settings Demo" -commandaction menu1sel]
$form setcurrent

foreach s {"-color"
    "-alphalevels"
    "-alertimagewidth"
    "-alertimageheight"
    "-listimagewidth"
    "-listimageheight"
    "-choiceimagewidth"
    "-choiceimageheight"
    "-bg"
    "-fg"
    "-hilightbg"
    "-hilightfg"
    "-border"
    "-hilightborder"
    "-borderstyle"
    "-hilightborderstyle"
} {
    $form append [lcdui.stringitem -label "[strtrim $s -]:" -text \
        [lcdui.settings cget $s]]
}</programlisting>

	  <para>
	    Live example: <link xl:href="http://www.heclbuilder.com/scripts/show/152" />
	  </para>
	</refsect1>
      </refentry>

      <refentry xml:id="lcdui_spacer">
	<refnamediv>
	  <refname>lcdui.spacer</refname>
	  <refpurpose>Creates a spacer element in a form.</refpurpose>
	</refnamediv>
	<refsynopsisdiv>
	  <cmdsynopsis>
	    <command>lcdui.spacer</command>
	    <arg choice="req">-minwidth <replaceable>minimum width</replaceable></arg>
	    <arg choice="req">-minheight <replaceable>minimum height</replaceable></arg>
	  </cmdsynopsis>

	  <note>
	    <para>
	      Image items also utilize the common "item" options, described
	      here: <link linkend="lcdui_item_options">lcdui item options</link>
	    </para>
	  </note>

	</refsynopsisdiv>
	<refsect1>
	  <title>Description</title>
	  <para>
	    The <command>lcdui.spacer</command> command creates a spacer to separate form elements.
	    Via the <option>-minwidth</option> and <option>-minheight</option> options, you can
	    specify the minimum width and height.  For an in-depth look at the Java code that this
	    command is based on, see: <link xl:href="http://java.sun.com/javame/reference/apis/jsr118/javax/microedition/lcdui/Spacer.html">javax.microedition.lcdui.Spacer</link>
	  </para>
	</refsect1>
      </refentry>

      <refentry xml:id="lcdui_stringitem">
	<refnamediv>
	  <refname>lcdui.stringitem</refname>
	  <refpurpose>Creates a string item that can be added to a form.</refpurpose>
	</refnamediv>
	<refsynopsisdiv>
	  <cmdsynopsis>
	    <command>lcdui.stringitem</command>
	    <arg choice="req">-label <replaceable>label</replaceable></arg>
	    <arg choice="req">-text <replaceable>text</replaceable></arg>
	  </cmdsynopsis>

	  <cmdsynopsis>
	    <command><replaceable>$stringitemcmd</replaceable></command>
	    <arg choice="opt">cget
	      <group choice="req">
		<arg choice="req">-appearance</arg>
		<arg choice="req">-text</arg>
		<arg choice="req">-font</arg>
	      </group>
	    </arg>

	    <arg choice="opt">configure
	      <group choice="req">
		<arg choice="req">-appearance
		  <group choice="req">
		    <arg choice="req">plain</arg>
		    <arg choice="req">button</arg>
		    <arg choice="req">hyperlink</arg>
		  </group>
		</arg>
		<arg choice="req">-text <replaceable>text</replaceable></arg>
		<arg choice="req">-font <replaceable>font</replaceable></arg>
	      </group>
	    </arg>
	  </cmdsynopsis>

	  <note>
	    <para>
	      String items also utilize the common "item" options, described
	      here: <link linkend="lcdui_item_options">lcdui item options</link>
	    </para>
	  </note>

	</refsynopsisdiv>
	<refsect1>
	  <title>Description</title>
	  <para>
	    The <command>lcdui.stringitem</command> command creates a string item (label + text)
	    that can be attached to a form.  Normally, the label is bold, and the text is in the
	    default font.  For an in-depth look at the Java code that this command is based on, see:
	    <link xl:href="http://java.sun.com/javame/reference/apis/jsr118/javax/microedition/lcdui/StringItem.html">javax.microedition.lcdui.StringItem</link>
	  </para>
	</refsect1>
      </refentry>

      <refentry xml:id="lcdui_textbox">
	<refnamediv>
	  <refname>lcdui.textbox</refname>
	  <refpurpose>Creates a text box for editing larger blocks of text.</refpurpose>
	</refnamediv>
	<refsynopsisdiv>
	  <cmdsynopsis>
	    <command>lcdui.textbox</command>
	    <arg choice="req">-title <replaceable>title</replaceable></arg>
	    <arg choice="req">-text <replaceable>text</replaceable></arg>
	    <arg choice="req">-maxlen <replaceable>maxlen</replaceable></arg>
	    <arg choice="req">-type
	      <group choice="req">
		<arg choice="req">any</arg>
		<arg choice="req">emailaddr</arg>
		<arg choice="req">numeric</arg>
		<arg choice="req">phonenumber</arg>
		<arg choice="req">decimal</arg>
	      </group>
	    </arg>
	  </cmdsynopsis>

	  <cmdsynopsis>
	    <command><replaceable>$textboxcmd</replaceable></command>
	    <arg choice="opt">cget
	      <group choice="req">
		<arg choice="req">-type</arg>
		<arg choice="req">-text</arg>
		<arg choice="req">-maxlen</arg>
		<arg choice="req">-password</arg>
		<arg choice="req">-uneditable</arg>
		<arg choice="req">-sensitive</arg>
		<arg choice="req">-non_predictive</arg>
		<arg choice="req">-initial_caps_word</arg>
		<arg choice="req">-caretposition</arg>
	      </group>
	    </arg>

	    <arg choice="opt">
	      configure
	      <group choice="req">
		<arg choice="req">-type <option><replaceable>type</replaceable></option></arg>
		<arg choice="req">-text <replaceable>text</replaceable></arg>
		<arg choice="req">-maxlen <replaceable>maxlen</replaceable></arg>
		<arg choice="req">-password
		  <group choice="req">
		    <arg choice="req">1</arg>
		    <arg choice="req">0</arg>
		  </group>
		</arg>
		<arg choice="req">-uneditable
		  <group choice="req">
		    <arg choice="req">1</arg>
		    <arg choice="req">0</arg>
		  </group>
		</arg>
		<arg choice="req">-sensitive
		  <group choice="req">
		    <arg choice="req">1</arg>
		    <arg choice="req">0</arg>
		  </group>
		</arg>
		<arg choice="req">-non_predictive
		  <group choice="req">
		    <arg choice="req">1</arg>
		    <arg choice="req">0</arg>
		  </group>
		</arg>
		<arg choice="req">-initial_caps_word
		  <group choice="req">
		    <arg choice="req">1</arg>
		    <arg choice="req">0</arg>
		  </group>
		</arg>
	      </group>
	    </arg>
	  </cmdsynopsis>

	</refsynopsisdiv>
	<refsect1>
	  <title>Description</title>
	  <para>
	    The <command>lcdui.textbox</command> command creates a full-screen text editing widget
	    that can be used for editing longer, multi-line chunks of text.  For an in-depth look at
	    the Java code that this command is based on, see: <link xl:href="http://java.sun.com/javame/reference/apis/jsr118/javax/microedition/lcdui/TextBox.html">javax.microedition.lcdui.TextBox</link>
	  </para>
	  <para>There are several options governing the functionality of this widget.  Note that
	  more than one constraint may be selected at a time:</para>
	  <itemizedlist>
	    <listitem>
	      <para><option>-password</option>: If 1, obscure the data as it is entered.
              </para>
	    </listitem>

	    <listitem>
	      <para><option>-uneditable</option>: If 1, the user is not allowed to edit the
	      displayed text.
              </para>
	    </listitem>

	    <listitem>
	      <para><option>-sensitive</option>: If 1, "indicates that the text entered is
	      sensitive data that the implementation must never store into a dictionary or table for
	      use in predictive, auto-completing, or other accelerated input schemes."
              </para>
	    </listitem>

	    <listitem>
	      <para><option>-non_predictive</option>: Don't use the local text-completion system if
	      this option is set.
              </para>
	    </listitem>

	    <listitem>
	      <para><option>-initial_caps_word</option>: The initial letter of each word should be
	      capitalized if this option is set.
	      </para>
	    </listitem>

	    <listitem>
	      <para><option>-initial_caps_sentence</option>: The initial letter of each sentence
		should be capitalized if this option is set.
	      </para>
	    </listitem>
	  </itemizedlist>
	</refsect1>
	<refsect1>
	  <title>Example</title>
	  <programlisting>
set evalcmd [lcdui.command -label Evaluate -longlabel Evaluate]
set textbox [lcdui.textbox -text {[lcdui.alert -text "hi!"] setcurrent} \
	-commandaction runCode]
$textbox setcurrent
$textbox addcommand $evalcmd

proc runCode {cmd txtbox} {
    eval [$txtbox cget -text]
}</programlisting>

	  <para>
	    Live example: <link xl:href="http://www.heclbuilder.com/scripts/show/153" />
	  </para>

	</refsect1>
      </refentry>

      <refentry xml:id="lcdui_textfield">
	<refnamediv>
	  <refname>lcdui.textfield</refname>
	  <refpurpose>Creates a small text editing widget that can be attached to a
	  form.</refpurpose>
	</refnamediv>
	<refsynopsisdiv>
	  <cmdsynopsis>
	    <command>lcdui.textfield</command>
	    <arg choice="req">-label <replaceable>label</replaceable></arg>
	    <arg choice="req">-text <replaceable>text</replaceable></arg>
	    <arg choice="req">-maxlen <replaceable>maxlen</replaceable></arg>
	    <arg choice="req">-type
	      <group choice="req">
		<arg choice="req">any</arg>
		<arg choice="req">emailaddr</arg>
		<arg choice="req">numeric</arg>
		<arg choice="req">phonenumber</arg>
		<arg choice="req">decimal</arg>
	      </group>
	    </arg>
	  </cmdsynopsis>

	  <cmdsynopsis>
	    <command><replaceable>$textfieldcmd</replaceable></command>
	    <arg choice="opt">cget
	      <group choice="req">
		<arg choice="req">-type</arg>
		<arg choice="req">-text</arg>
		<arg choice="req">-maxlen</arg>
		<arg choice="req">-password</arg>
		<arg choice="req">-uneditable</arg>
		<arg choice="req">-sensitive</arg>
		<arg choice="req">-non_predictive</arg>
		<arg choice="req">-initial_caps_word</arg>
		<arg choice="req">-caretposition</arg>
	      </group>
	    </arg>

	    <arg choice="opt">
	      configure
	      <group choice="req">
		<arg choice="req">-type <option><replaceable>type</replaceable></option></arg>
		<arg choice="req">-text <replaceable>text</replaceable></arg>
		<arg choice="req">-maxlen <replaceable>maxlen</replaceable></arg>
		<arg choice="req">-password
		  <group choice="req">
		    <arg choice="req">1</arg>
		    <arg choice="req">0</arg>
		  </group>
		</arg>
		<arg choice="req">-uneditable
		  <group choice="req">
		    <arg choice="req">1</arg>
		    <arg choice="req">0</arg>
		  </group>
		</arg>
		<arg choice="req">-sensitive
		  <group choice="req">
		    <arg choice="req">1</arg>
		    <arg choice="req">0</arg>
		  </group>
		</arg>
		<arg choice="req">-non_predictive
		  <group choice="req">
		    <arg choice="req">1</arg>
		    <arg choice="req">0</arg>
		  </group>
		</arg>
		<arg choice="req">-initial_caps_word
		  <group choice="req">
		    <arg choice="req">1</arg>
		    <arg choice="req">0</arg>
		  </group>
		</arg>
	      </group>
	    </arg>
	  </cmdsynopsis>


	</refsynopsisdiv>
	<refsect1>
	  <title>Description</title>
	  <para>
	    The <command>lcdui.textfield</command> command creates a one-line text editing widget
	    that can be attached to a form.  For an in-depth look at the Java code that this command
	    is based on, see: <link xl:href="http://java.sun.com/javame/reference/apis/jsr118/javax/microedition/lcdui/TextBox.html">javax.microedition.lcdui.TextBox</link>
	  </para>
	</refsect1>
	<refsect1>
	  <title>Example</title>
	  <programlisting>
set evalcmd [lcdui.command -label Evaluate -longlabel Evaluate]
set textfield [lcdui.textfield -text {[lcdui.alert -text "hi!"] setcurrent}]
set form [lcdui.form -title "Text Field Example" -commandaction \
    [list runCode $textfield]]
$form append $textfield
$form setcurrent
$form addcommand $evalcmd

proc runCode {txtfld cmd frm} {
    eval [$txtfld cget -text]
}</programlisting>

	  <para>
	    Live example: <link xl:href="http://www.heclbuilder.com/scripts/show/154" />
	  </para>

	</refsect1>
      </refentry>

      <refentry xml:id="lcdui_ticker">
	<refnamediv>
	  <refname>lcdui.ticker</refname>
	  <refpurpose>Creates a ticker that scrolls horizontally.</refpurpose>
	</refnamediv>
	<refsynopsisdiv>
	  <cmdsynopsis>
	    <command>lcdui.ticker</command>
	    <arg choice="req">-text <replaceable>text</replaceable></arg>
	  </cmdsynopsis>
	</refsynopsisdiv>
	<refsect1>
	  <title>Description</title>
	  <para>
	    The <command>lcdui.ticker</command> command creates a ticker that runs horizontally
	    across the screen.  For an in-depth look at the Java code that this command is based on,
	    see: <link xl:href="http://java.sun.com/javame/reference/apis/jsr118/javax/microedition/lcdui/TextBox.html">javax.microedition.lcdui.TextBox</link>
	  </para>
	</refsect1>
	<refsect1>
	  <title>Example</title>
	  <programlisting>
set ticker [lcdui.ticker -text "The time is [clock format [clock time]]"]
set form [lcdui.form -title "Ticker Example" -ticker $ticker]
$form setcurrent

proc updateTicker {ticker} {
    $ticker configure -text "The time is [clock format [clock time]]"
    after 1000 [list updateTicker $ticker]
}

after 1000 [list updateTicker $ticker]</programlisting>

	  <para>
	    Live example: <link xl:href="http://www.heclbuilder.com/scripts/show/155" />
	  </para>
	</refsect1>
      </refentry>

      <refentry xml:id="lcdui_item_options">
	<refnamediv>
	  <refname>lcdui item options</refname>
	  <refpurpose>common options for <link
	  linkend="lcdui_choicegroup">lcdui.choicegroup</link>, <link
	  linkend="lcdui_date">lcdui.date</link>, <link
	  linkend="lcdui_gauge">lcdui.gauge</link>, <link
	  linkend="lcdui_imageitem">lcdui.imageitem</link>, <link
	  linkend="lcdui_spacer">lcdui.spacer</link>, and <link
	  linkend="lcdui_stringitem">lcdui.stringitem</link></refpurpose>
	</refnamediv>
	<refsection>
	  <title>Common lcdui item options</title>
	  <para>
	    The lcdui "item" elements have a number of options in common, which
	    are described here.
	  </para>
	  <para>
	    Many of these options are layout options, and correspond to what is
	    described here: <link
	    xl:href="http://java.sun.com/javame/reference/apis/jsr118/javax/microedition/lcdui/Form.html#layout">http://java.sun.com/javame/reference/apis/jsr118/javax/microedition/lcdui/Form.html#layout</link>
	  </para>
	  <itemizedlist>
	    <title>lcdui item configuration options</title>
	    <para>
	      These options may be set as follows, or as options at the time the
	      item is created.
	    </para>
	    <cmdsynopsis>
	      <command>$itemcmd</command>
	      <arg choice="req">configure</arg>
	      <arg choice="req"><replaceable>-optname</replaceable></arg>
	      <arg choice="req"><replaceable>optvalue</replaceable></arg>
	    </cmdsynopsis>

	    <listitem>
	      <para>
	      <option>-label <replaceable>text</replaceable></option>: the item's label</para>
	    </listitem>

	    <listitem>
	      <para><option>-anchor <replaceable>position</replaceable></option>: One of the following
	      positions.  For more information, see <link
	      xl:href="http://java.sun.com/javame/reference/apis/jsr118/javax/microedition/lcdui/Graphics.html">http://java.sun.com/javame/reference/apis/jsr118/javax/microedition/lcdui/Graphics.html</link>
	      </para>
	      <itemizedlist>
		<listitem>
		  <para><constant>n</constant>: top/center</para>
		</listitem>
		<listitem>
		  <para><constant>ne</constant>: top/right</para>
		</listitem>
		<listitem>
		  <para><constant>e</constant>: right/vertically centered</para>
		</listitem>
		<listitem>
		  <para><constant>se</constant>: bottom/right</para>
		</listitem>
		<listitem>
		  <para><constant>s</constant>: bottom/center</para>
		</listitem>
		<listitem>
		  <para><constant>sw</constant>: bottom/left</para>
		</listitem>
		<listitem>
		  <para><constant>w</constant>: left/vertically centered</para>
		</listitem>
		<listitem>
		  <para><constant>nw</constant>: top/left</para>
		</listitem>
		<listitem>
		  <para><constant>center</constant>: horizontally and vertically centered</para>
		</listitem>
		<listitem>
		  <para><constant>default</constant>: top/left</para>
		</listitem>
		<listitem>
		  <para><constant>bl</constant>: left/baseline</para>
		</listitem>
		<listitem>
		  <para><constant>bc</constant>: centered/baseline</para>
		</listitem>
		<listitem>
		  <para><constant>br</constant>: right/baseline</para>
		</listitem>
	      </itemizedlist>
	    </listitem>

	    <listitem>
	      <para>
		<option>-shrink <replaceable>1 | 0</replaceable></option>
		Indicate that this item's width may be reduced to its minimum
		width.
	      </para>
	    </listitem>

	    <listitem>
	      <para>
		<option>-expand <replaceable>1 | 0</replaceable></option>
		Indicate that this item's width may be increased to fill available space.
		width.
	      </para>
	    </listitem>

	    <listitem>
	      <para>
		<option>-vexpand <replaceable>1 | 0</replaceable></option>
		Indicate that this item's height may be increased to fill available space.
		width.
	      </para>
	    </listitem>

	    <listitem>
	      <para>
		<option>-newlinebefore <replaceable>1 | 0</replaceable></option>
		Indicate that the next item (if any) in the container should be
		placed on a new line or row.
	      </para>
	    </listitem>

	    <listitem>
	      <para>
		<option>-newlineafter <replaceable>1 | 0</replaceable></option>
		Indicate that this item should be placed at the beginning of a
		new line or row.
	      </para>
	    </listitem>

	    <listitem>
	      <para>
		<option>-layout2 <replaceable>1 | 0</replaceable></option>
		A layout directive indicating that new MIDP 2.0 layout rules are in effect for this item.
	      </para>
	    </listitem>

	    <listitem>
	      <para>
		<option>-preferredwidth <replaceable>width</replaceable></option>
		Preferred width for the item.
	      </para>
	    </listitem>

	    <listitem>
	      <para>
		<option>-preferredheight <replaceable>height</replaceable></option>
		Preferred height for the item.
	      </para>
	    </listitem>

	    <listitem>
	      <para>
		<option>-defaultcommand
		<replaceable>command</replaceable></option> If this item is
		clicked on, the default command to call.
		<option><replaceable>command</replaceable></option> refers to a
		command object, and not a Hecl proc or command.
	      </para>
	    </listitem>

	    <listitem>
	      <para>
		<option>-commandaction
		<replaceable>command</replaceable></option>

		The Hecl command to call when a command is dispatched.
	      </para>
	    </listitem>

	  </itemizedlist>

	  <itemizedlist>
	    <title>read-only configuration information</title>
	    <para>
	      All of the above attributes may be read as well as written. There
	      are several more attributes that are "read only".  They can be
	      obtained like so:
	    </para>
	    <cmdsynopsis>
	      <command>$itemcmd</command>
	      <arg choice="req">cget</arg>
	      <arg choice="req"><replaceable>-optname</replaceable></arg>
	      <arg choice="req"><replaceable>optvalue</replaceable></arg>
	    </cmdsynopsis>
	    <listitem>
	      <para>
		<option>-minwidth</option> : Returns the minimum width for this item.
	      </para>
	    </listitem>
	  </itemizedlist>

	  <itemizedlist>
	    <listitem>
	      <para>
		<option>-minheight</option> : Returns the minimum height for this item.
	      </para>
	    </listitem>
	  </itemizedlist>

	</refsection>
      </refentry>

      <refentry xml:id="midlet_exit">
	<refnamediv>
	  <refname>midlet.exit</refname>
	  <refpurpose>Exit from the Midetl</refpurpose>
	</refnamediv>
	<refsynopsisdiv>
	  <cmdsynopsis>
	    <command>midlet.exit</command>
	  </cmdsynopsis>
	</refsynopsisdiv>
	<refsect1>
	  <title>Description</title> <para>Exit from the current Midlet by calling
	  <methodname>notifyDestroyed</methodname></para>
	</refsect1>
      </refentry>

      <refentry xml:id="midlet_pause">
	<refnamediv>
	  <refname>midlet.pause</refname>
	  <refpurpose>Pause the current midlet</refpurpose>
	</refnamediv>
	<refsynopsisdiv>
	  <cmdsynopsis>
	    <command>midlet.pause</command>
	  </cmdsynopsis>
	</refsynopsisdiv>
	<refsect1>
	  <title>Description</title>
	  <para>
	    Pause the current midlet by calling the <methodname>notifyPaused</methodname> method.
	  </para>
	</refsect1>
      </refentry>

      <refentry xml:id="midlet_resume">
	<refnamediv>
	  <refname>midlet.resume</refname>
	  <refpurpose>Resume execution of the current midlet</refpurpose>
	</refnamediv>
	<refsynopsisdiv>
	  <cmdsynopsis>
	    <command>midlet.resume</command>
	  </cmdsynopsis>
	</refsynopsisdiv>
	<refsect1>
	  <title>Description</title>
	  <para>
	    Attempts to resume execution of the midlet by calling the
	    <methodname>resumeRequest</methodname> method.
	  </para>
	</refsect1>
      </refentry>

      <refentry xml:id="midlet_onpause">
	<refnamediv>
	  <refname>midlet.onpause</refname>
	  <refpurpose>Hook to call when midlet execution is paused</refpurpose>
	</refnamediv>
	<refsynopsisdiv>
	  <cmdsynopsis>
	    <command>midlet.onpause</command>
	  </cmdsynopsis>
	</refsynopsisdiv>
	<refsect1>
	  <title>Description</title>
	  <para>
	    If this command is defined in the interpreter, it is called before the midlet is paused.
	  </para>
	</refsect1>
      </refentry>

      <refentry xml:id="midlet_onresume">
	<refnamediv>
	  <refname>midlet.onresume</refname>
	  <refpurpose>Hook to call when midlet execution is resumed</refpurpose>
	</refnamediv>
	<refsynopsisdiv>
	  <cmdsynopsis>
	    <command>midlet.onresume</command>
	  </cmdsynopsis>
	</refsynopsisdiv>
	<refsect1>
	  <title>Description</title>
	  <para>
	    If this command is defined in the interpreter, it is called when execution of the midlet
	    is resumed.
	  </para>
	</refsect1>
      </refentry>

      <refentry xml:id="midlet_checkpermissions">
	<refnamediv>
	  <refname>midlet.checkpermissions</refname>
	  <refpurpose>Query permission information</refpurpose>
	</refnamediv>
	<refsynopsisdiv>
	  <cmdsynopsis>
	    <command>midlet.checkpermissions</command>
	    <arg choice="req"><replaceable>permission_name</replaceable></arg>
	  </cmdsynopsis>
	</refsynopsisdiv>
	<refsect1>
	  <title>Description</title>
	  <para>
	    This command returns information about whether a given permission has been granted to
	    the midlet.  Quoting from the Java documentation:
	  </para>
	  <blockquote>
	    <para>
	      Get the status of the specified permission. If no API on
	      the device defines the specific permission requested
	      then it must be reported as denied. If the status of the
	      permission is not known because it might require a user
	      interaction then it should be reported as unknown.
	    </para>
	  </blockquote>
	  <para>
	    The command returns 0 if the permission is denied; 1 if the permission is allowed, and
	    -1 if the status is unknown
	  </para>
	</refsect1>
	<refsect1>
	  <title>Example</title>
	  <programlisting>
midlet.checkpermissions "javax.microedition.io.Connector.file.read"
	  </programlisting>
	</refsect1>
      </refentry>

      <refentry xml:id="midlet_getappproperty">
	<refnamediv>
	  <refname>midlet.getappproperty</refname>
	  <refpurpose>Get application properties</refpurpose>
	</refnamediv>
	<refsynopsisdiv>
	  <cmdsynopsis>
	    <command>midlet.getappproperty</command>
	    <arg choice="req"><replaceable>propertyname</replaceable></arg>
	  </cmdsynopsis>
	</refsynopsisdiv>
	<refsect1>
	  <title>Description</title>
	  <para>
	    Lets the midlet retrieve application properties, as defined in the .jad file.
	  </para>
	  <para>
	    See also: <link linkend="system_getproperty">system.getproperty</link>
	  </para>
	</refsect1>
      </refentry>

      <refentry xml:id="midlet_platformrequest">
	<refnamediv>
	  <refname>midlet.platformrequest</refname>
	  <refpurpose>Perform platform-specific actions</refpurpose>
	</refnamediv>
	<refsynopsisdiv>
	  <cmdsynopsis>
	    <command>midlet.platformrequest</command>
	    <arg choice="req"><replaceable>url</replaceable></arg>
	  </cmdsynopsis>
	</refsynopsisdiv>
	<refsect1>
	  <title>Description</title>
	  <para>
	    From the Javadocs:
	  </para>
	  <blockquote>
	    <para>Requests that the device handle (for example, display or install) the indicated URL.</para>

	    <para>If the platform has the appropriate capabilities and resources available, it
	    SHOULD bring the appropriate application to the foreground and let the user interact
	    with the content, while keeping the MIDlet suite running in the background. If the
	    platform does not have appropriate capabilities or resources available, it MAY wait to
	    handle the URL request until after the MIDlet suite exits. In this case, when the
	    requesting MIDlet suite exits, the platform MUST then bring the appropriate application
	    (if one exists) to the foreground to let the user interact with the content.</para>
	  </blockquote>
	  <para>
	    In other words, depending on the device, you can launch applications with
	    midlet.platformrequest.  For example:
	  </para>
	  <programlisting>
# Make a phone call
midlet.platformrequest "tel:+393488866859"
# Start the sms sending application
midlet.platformrequest "sms:+393488866859"
# Open a web page
midlet.platformrequest "http://www.hecl.org"
# Install the jad/jar
midlet.platformrequest "http://www.hecl.org/jars/cldc1.1-midp2.0/Hecl.jad"
	  </programlisting>

	  <note>
	    <para>
	      There is not much standard about this command.  It may
	      or may not support different url types on different
	      phones.  Making phone calls with "tel:" URL's should
	      always work.  Also, keep in mind that on some devices,
	      launching an external application may terminate the
	      currently running midlet.
	    </para>
	  </note>
	</refsect1>
      </refentry>

      <refentry xml:id="midlet_resourceasstring">
	<refnamediv>
	  <refname>midlet.resourceasstring</refname>
	  <refpurpose>Get a resource file as a string</refpurpose>
	</refnamediv>
	<refsynopsisdiv>
	  <cmdsynopsis>
	    <command>midlet.resourceasstring</command>
	    <arg choice="req"><replaceable>resourcename</replaceable></arg>
	  </cmdsynopsis>
	</refsynopsisdiv>
	<refsect1>
	  <title>Description</title>
	  <para>
	    Given a resource <option><replaceable>resourcename</replaceable></option>, returns it as
	    a string.  This could be used, for instance, to load additional Hecl files.
	  </para>
	</refsect1>
	<refsect1>
	  <title>Example</title>
	  <programlisting>
eval [midlet.resourceasstring "./more_commands.hcl"]
	  </programlisting>
	</refsect1>
      </refentry>

      <refentry xml:id="midlet_flashbacklight">
	<refnamediv>
	  <refname>midlet.flashbacklight</refname>
	  <refpurpose>Flash the device's backlight</refpurpose>
	</refnamediv>
	<refsynopsisdiv>
	  <cmdsynopsis>
	    <command>midlet.vibrate</command>
	    <arg choice="req"><replaceable>milliseconds</replaceable></arg>
	  </cmdsynopsis>
	</refsynopsisdiv>
	<refsect1>
	  <title>Description</title>
	  <para>
	    Flashes the device's backlight for N milliseconds.  Returns 1 if the light can be
	    controlled by the application, and the display is in the foreground; otherwise, 0.
	  </para>
	</refsect1>
      </refentry>

      <refentry xml:id="midlet_vibrate">
	<refnamediv>
	  <refname>midlet.vibrate</refname>
	  <refpurpose>Vibrate the device</refpurpose>
	</refnamediv>
	<refsynopsisdiv>
	  <cmdsynopsis>
	    <command>midlet.vibrate</command>
	    <arg choice="req"><replaceable>milliseconds</replaceable></arg>
	  </cmdsynopsis>
	</refsynopsisdiv>
	<refsect1>
	  <title>Description</title>
	  <para>
	    Activates the device's vibrator for N milliseconds.  Returns 1 if the vibrator can be
	    controlled by the application and the display is in the foreground; otherwise 0.
	  </para>
	</refsect1>
      </refentry>

    </section>

    <section xml:id="hacking_hecl_j2me">
      <title>Hacking Hecl's Java ME code</title>

      <para>
	Since Java ME comes in several flavors that Hecl can be compiled for, it's necessary to
	understand what Hecl does, and how it does it.
      </para>

      <para>
	JavaME has two layers that are of interest to us, "CLDC" and "MIDP".  CLDC is available in
	1.0 and 1.1 configurations, whereas MIDP comes in 1.0 and 2.0 configurations.  The most
	common configurations are CLDC 1.0 and MIDP 1.0, CLDC 1.0 and MIDP 2.0, and CLDC 1.1 with
	MIDP 2.0.  Here are the Wikipedia entries describing <link xl:href="http://en.wikipedia.org/wiki/Connected_Limited_Device_Configuration">CLDC</link> and
	<link xl:href="http://en.wikipedia.org/wiki/MIDP">MIDP</link>.
      </para>

      <para>
	Hecl tries to match code to system resources: in other words, the code in the
	<filename>midp10/</filename> and <filename>midp10gui</filename> (MIDP 1.0) directories is
	smaller, simpler, and has fewer features than the code in <filename>midp20</filename> and
	<filename>midp20gui</filename> (MIDP 2.0), reflecting the fact that many 1.0 devices only
	allow very small jar files ("midlets").
      </para>

      <para>
	For MIDP 1.0, the <filename>midp10gui</filename> directory contains the
	<filename>GUICmds.java</filename>, which has most of the functionality that maps J2ME
	functionality to Hecl and back.  The <filename>midp10/Hecl.java</filename> file contains the
	code that starts up Hecl on the cell phone.  For MIDP 2.0, the
	<filename>midp20gui</filename> directory contains the GUI commands, and
	<filename>midp20/Hecl.java</filename> is where the application is launched from on the
	phone.
      </para>

      <para>
	In order to be able to deal with all these different versions, Hecl is more or less forced
	to utilize a Java preprocessor, which explains all the ifdef's in the code.  The various
	symbols are defined in the <filename>settings.xml</filename> file.
      </para>

      <para>
	To compile different combinations of things, Hecl makes a couple of property files
	available that are used like so:
      </para>
      <programlisting>
 ant -propertyfile ./cldc10midp10.properties midlet
      </programlisting>
      <para>
	Which compiles the CLDC 1.0 / MIDP 1.0 version of Hecl and places the jar in the
      <filename>jars/cldc1.0-midp1.0/</filename> directory, or:
      </para>
      <programlisting>
 ant -propertyfile ./cldc11midp20.properties midlet
      </programlisting>
      <para>Which compiles the CLDC 1.1 / MIDP 2.0 version, and places the jar in the
      <filename>jars/cldc1.1-midp2.0/</filename> directory.</para>
    </section>
  </section>

  <section xml:id="blackberry">
    <title>Hecl and BlackBerry</title>

    <para>
      The BlackBerry platform allows you to utilize Java ME code,
      which is what we do to make Hecl run on that platform.  This
      means that almost all of the <link linkend='midp20commands'>Java
      ME commands</link> are available, plus additional commands
      specific to the BlackBerry environment.
    </para>

    <section xml:id="blackberry_commands">
      <title>BlackBerry Commands</title>

      <refentry xml:id="browser_open">
	<refnamediv>
	  <refname>browser.open</refname>
	  <refpurpose>Launches the BlackBerry browser</refpurpose>
	</refnamediv>
	<refsynopsisdiv>
	  <cmdsynopsis>
	    <command>browser.open</command>
	    <arg choice="req"><replaceable>url</replaceable></arg>
	    <arg></arg>
	  </cmdsynopsis>
	</refsynopsisdiv>
	<refsect1>
	  <title>Description</title>
	  <para>
	    The <command>browser.open</command> command launches the
	    BlackBerry browser.  It does not block while the browser
	    remains open, so the execution of the Hecl script
	    continues.
	  </para>
	</refsect1>
      </refentry>

      <refentry xml:id="device_systemversion">
	<refnamediv>
	  <refname>device.systemversion</refname>
	  <refpurpose>Returns a string with the system version information</refpurpose>
	</refnamediv>
	<refsynopsisdiv>
	  <cmdsynopsis>
	    <command>device.systemversion</command>
	  </cmdsynopsis>
	</refsynopsisdiv>
	<refsect1>
	  <title>Description</title>
	  <para>
	    Returns a string containing the system version of the device.
	  </para>
	  <note>
	    <para>This always returns an empty string on the emulator</para>
	  </note>
	</refsect1>
      </refentry>

      <refentry xml:id="invoke_call">
	<refnamediv>
	  <refname>invoke.call</refname>
	  <refpurpose>Makes a phone call using the built-in dialer</refpurpose>
	</refnamediv>
	<refsynopsisdiv>
	  <cmdsynopsis>
	    <command>invoke.call</command>
	    <arg choice="req"><replaceable>phone_number</replaceable></arg>
	  </cmdsynopsis>
	</refsynopsisdiv>
	<refsect1>
	  <title>Description</title>
	  <para>
	    Makes a call to the specified phone number, using the built in "dial" application.
	  </para>
	</refsect1>
      </refentry>

      <refentry xml:id="invoke_calculator">
	<refnamediv>
	  <refname>invoke.calculator</refname>
	  <refpurpose>Opens the built in calculator application</refpurpose>
	</refnamediv>
	<refsynopsisdiv>
	  <cmdsynopsis>
	    <command>invoke.calculator</command>
	  </cmdsynopsis>
	</refsynopsisdiv>
	<refsect1>
	  <title>Description</title>
	  <para>
	    Launches the calculator application.
	  </para>
	</refsect1>
      </refentry>

      <refentry xml:id="invoke_camera">
	<refnamediv>
	  <refname>invoke.camera</refname>
	  <refpurpose>Starts the camera application</refpurpose>
	</refnamediv>
	<refsynopsisdiv>
	  <cmdsynopsis>
	    <command>invoke.camera</command>
	  </cmdsynopsis>
	</refsynopsisdiv>
	<refsect1>
	  <title>Description</title>
	  <para>
	    Launches the camera application.
	  </para>
	</refsect1>
      </refentry>

      <refentry xml:id="invoke_video">
	<refnamediv>
	  <refname>invoke.video</refname>
	  <refpurpose>Starts the video application</refpurpose>
	</refnamediv>
	<refsynopsisdiv>
	  <cmdsynopsis>
	    <command>invoke.video</command>
	  </cmdsynopsis>
	</refsynopsisdiv>
	<refsect1>
	  <title>Description</title>
	  <para>
	    Launches the video application.
	  </para>
	</refsect1>
      </refentry>

      <refentry xml:id="servicebook_records">
	<refnamediv>
	  <refname>servicebook.records</refname>
	  <refpurpose>Retrieves connection information about various connection types</refpurpose>
	</refnamediv>
	<refsynopsisdiv>
	  <cmdsynopsis>
	    <command>servicebook.records</command>
	  </cmdsynopsis>
	</refsynopsisdiv>
	<refsect1>
	  <title>Description</title>
	  <para>
	    This call returns a list of all "service records".  Each
	    record is a hash with the following fields defined.  For
	    their meanings, please refer to this link: <link
	    xl:href="http://www.blackberry.com/developers/docs/4.7.0api/net/rim/device/api/servicebook/ServiceRecord.html"></link>
	  </para>
	  <para>
	    <constant>APN</constant>
	    <constant>ApplicationData</constant>
	    <constant>BBRHosts</constant>
	    <constant>BBRHosts</constant>
	    <constant>BBRPorts</constant>
	    <constant>BBRPorts</constant>
	    <constant>CAAddress</constant>
	    <constant>CAPort</constant>
	    <constant>CARealm</constant>
	    <constant>CID</constant>
	    <constant>UID</constant>
	    <constant>CidHash</constant>
	    <constant>CompressionMode</constant>
	    <constant>DataSourceId</constant>
	    <constant>Description</constant>
	    <constant>DisabledState</constant>
	    <constant>EncryptionMode</constant>
	    <constant>HomeAddress</constant>
	    <constant>Id</constant>
	    <constant>KeyHashForService</constant>
	    <constant>LastUpdated</constant>
	    <constant>Name</constant>
	    <constant>NameHash</constant>
	    <constant>NetworkAddress</constant>
	    <constant>NetworkType</constant>
	    <constant>Source</constant>
	    <constant>Type</constant>
	    <constant>Uid</constant>
	    <constant>UidHash</constant>
	    <constant>UserId</constant>
	    <constant>isDirty</constant>
	    <constant>isDisabled</constant>
	    <constant>isEncrypted</constant>
	    <constant>isInvisible</constant>
	    <constant>isRecordProtected</constant>
	    <constant>isRestoredFromBackup</constant>
	    <constant>isRestoreDisabled</constant>
	    <constant>isRestoreEnabled</constant>
	    <constant>isSecureService</constant>
	    <constant>isValid</constant>
	    <constant>isWeakSecureService</constant>
	  </para>
	</refsect1>
      </refentry>


    </section>

  </section>

  <section xml:id="android">
    <title>Hecl and Android</title>

    <para>
      As of mid-2008, Hecl runs on Google's <link xl:href="http://code.google.com/android/">Android</link> platform, although it's not yet a
      'mature' port.  That's ok right now, though, because Android isn't production ready yet,
      either.
    </para>

    <para>Due to a different GUI model, a very extensive API, and a much more complete
      implementation of Java
      <footnote>
	<para>
	  Android doesn't actually run Java, it just compiles code written in Java into bytecodes for
	  the Dalvik engine.
	</para>
      </footnote>
      Hecl on Android takes a different approach: the Android version of Hecl includes a
      <command>java</command> command, and introspection capabilities in order to be able to
      dynamically create Hecl commands that call out to native Java calls.
    </para>

    <section xml:id="android_quick_start">
      <title>Android Hecl Quick Start</title>

      <para>
	Developing for Android Hecl is quite similar to Java ME development, with the same cycle of
	editing a script, creating an application bundle, and testing it in an emulator.
      </para>


      <procedure>

	<step>
	  <para>
	    To work with Android, of course the first thing you need to do is to get the SDK from
	    Google: <link xl:href="http://code.google.com/android/download.html" />.  On my system, I
	    installed it in here: <filename>/opt/android-sdk/</filename>.
	  </para>
	</step>

	<step>
	  <para>Next, edit <filename>android/android.properties</filename> to point to the SDK, and
	    the tools it needs to work (usually the <filename>tools</filename> directory within the
	    SDK directory).</para>
	</step>

	<step>
	  <para>As with Java ME Hecl, you need a script file to work with.  Here's a "hello
	  world":</para>
	  <programlisting>set context [activity]
set layout [linearlayout -new $context]
$layout setorientation VERTICAL
set layoutparams [linearlayoutparams -new {FILL_PARENT WRAP_CONTENT}]

set tv [textview -new $context -text {Hello World} \
                 -layoutparams $layoutparams]

$layout addview $tv
[activity] setcontentview $layout
</programlisting>

	  <para>
	    To see more code, have a look at <filename>android/res/raw/script.hcl</filename>, which
	    has examples of many different widgets.
	  </para>

	</step>

	<step>
	  <para>You won't need it right away, but you might as well start the emulator:</para>
	  <programlisting>/opt/android-sdk/tools/emulator -avd your_avd</programlisting>
	  <note>
	    <para>
	      You need to create an "AVD" before launching the emulator.  This is documented here:
		<link xl:href="http://developer.android.com/guide/developing/tools/emulator.html#avds"></link>
	    </para>
	  </note>
	</step>

	<step>
	  <para>Now we create the new <filename>Hello.apk</filename> file.
	  </para>

	  <programlisting>java -jar ./hecl/jars/AndroidBuilder.jar -android \
    /opt/android-sdk/platforms/android-1.5/ -class Hello \
    -label Hello -package hello.world \
    -script hello.hcl</programlisting>

	  <note>
	    <para>It's important to point out that the directory used with the
	      <option>-android</option> option is a subdirectory of the SDK:
	      <filename>/opt/android-sdk/platforms/android-1.5/</filename>, rather than the top
	      level.</para>
	  </note>

	  <para>
	    The command line options are as follows:
	  </para>

	  <simplelist>
	    <member><option>-android</option>: The location of the Android SDK.
	    </member>
	    <member><option>-class</option>: The class name to utilize for the new .apk.</member>
	    <member><option>-label</option>: The user-visible name of the package.</member>
	    <member><option>-package</option>: The Java package to use.  You can pretty much use any
	    name you like, it doesn't matter much.</member>
	    <member><option>-script</option>: The location of the script you want to use in the new .apk.</member>
	  </simplelist>


	</step>

	<step>
	  <para>
	    We now have a <filename>Hecl.apk</filename> file.  We need to sign it with the debug
	    key:
	    <programlisting>keytool -genkeypair -keystore debug.keystore \
    -keypass android -alias androiddebugkey -storepass android \
    -dname "CN=Android Debug,O=Android,C=US"</programlisting>
	    <programlisting>jarsigner -keystore debug.keystore -keypass android \
    -storepass android -verbose Hello.apk androiddebugkey</programlisting>
	  </para>
	</step>

	<step>
	  <para>At this piont, we can send the signed file, <filename>Hello.apk</filename> to the emulator:
	  </para>
	  <programlisting>/opt/android-sdk_m5-rc15_linux-x86/tools/adb install Hello.apk</programlisting>

	</step>

      </procedure>

    </section>

  </section>

</article>
